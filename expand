#![feature(prelude_import)]
#![feature(box_syntax, box_patterns)]
#![warn(clippy :: pendantic)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
use std::path::PathBuf;

#[macro_use]
mod ast {





    //println!("{}", STEGI_ASCII);

    //let mut path = std::env::current_dir().expect("failed to get working dir");
    //path.push("examples/test.st");
    use super::lexer::*;
    use crate::errors::*;
    use crate::errors::*;
    use crate::interp::*;
    use crate::typer::*;
    use std::convert::TryFrom;
    use derivative::*;
    use std::fmt;
    pub type AST = Vec<Decl>;
    pub trait ASTNode {
        fn accept<V: Visitor>(&mut self, visitor: &mut V)
        -> V::Result;
    }
    pub trait Visitor {
        type Result;
        fn visit_decl(&mut self, decl: &mut Decl)
        -> Self::Result;
        fn visit_stmt(&mut self, stmt: &mut Stmt)
        -> Self::Result;
        fn visit_expr(&mut self, expr: &mut Expr)
        -> Self::Result;
    }
    #[derivative(PartialEq, Debug, Clone)]
    pub enum ExprKind {

        /// normal binary expression, only used for numeric expressions
        /// example: a      +     42
        ///          ^-rhs  ^-op  ^-lhs
        Binary {
            lhs: Box<Expr>,
            rhs: Box<Expr>,
            op: BinaryOp,
        },

        /// just like a normal binary expression but only used for logical expressions
        /// example: a      &&    b
        ///          ^-rhs  ^-op  ^-lhs
        Logical {
            lhs: Box<Expr>,
            rhs: Box<Expr>,
            op: CmpOp,
        },

        /// one sided expression
        /// example: -    3
        ///          ^-op ^-rhs
        Unary {
            rhs: Box<Expr>,
            op: UnaryOp,
        },

        /// struct literals are used to initialize objects with values
        /// example: Person {name: "Torben"}
        ///          ^-name  ^^^^^^^^^^^^^^- member with name and init expr
        Struct {
            name: Ident,
            members: Vec<Member>,
        },

        /// a tuple expression is just a collection of other expressions
        /// example: (20,    20)
        ///           ^-expr ^-expr
        #[derivative(Debug = "transparent")]
        Tup(Vec<Expr>),

        /// variable reference, possibly containing `::` to refer to types in other moduels
        /// example: foo::bar
        ///          ^^^-segment
        #[derivative(Debug = "transparent")]
        Path(Path),

        /// used to represent all sorts of index expressions
        /// example: foo[     expr     ]
        ///          ^-callee ^index
        Index {
            callee: Box<Expr>,
            index: Box<Expr>,
        },

        /// array literals are used to initialize arrays with values
        /// example: [1, 2, 3, 4, 5]
        ///           ^-create new array with values from 1 to including 5
        #[derivative(Debug = "transparent")]
        Array(Vec<Expr>),

        /// a range pattern
        /// example: 0   ..   10
        ///           ^-start ^-end
        Range(Box<Expr>, Box<Expr>),

        /// a raw literal is the smallest possible expression
        /// example: 42
        ///          ^-num literal
        /// example: "foo"
        ///          ^-string/text literal
        #[derivative(Debug = "transparent")]
        Lit(Lit),

        /// access of a named struct field like a.b
        /// example: a  .    b
        ///          ^-callee ^ field
        Field(Box<Expr>, Ident),

        /// refers to a object instance and can be used to refer to that instance and it's member fields e.g. (selbst.foo)
        /// if a function contains self as an argument in it's signature it automatically becomes an associated 'Method' with that datatype
        /// NOTE: there are a few restrictions while using self in a function
        /// 1. self can only be used inside impl blocks
        /// 2. if a function contains self in it's signature self has to be the first parameter
        /// 3. the self parameter does not need to have any addition type information
        /// example: selbst    .     foo
        ///          ^-instance ptr  ^-member field
        This,

        /// refers to a live object or value, this basically represents an evaluated expression
        Val(Value),
        Intrinsic {
            kind: Intrinsic,
            args: Vec<Expr>,
        },

        /// function call e.g. foo(-42, 1, 1)
        /// example: foo    (-42,     10)
        ///          ^-callee ^-arg0  ^-arg1
        Call {
            callee: Box<Expr>,
            args: Vec<Expr>,
        },
    }
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ExprKind {
        fn clone(&self) -> Self {
            match *self {
                ExprKind::Binary {
                lhs: ref __arg_0, rhs: ref __arg_1, op: ref __arg_2 } => {
                    ExprKind::Binary{lhs: __arg_0.clone(),
                                     rhs: __arg_1.clone(),
                                     op: __arg_2.clone(),}
                }
                ExprKind::Logical {
                lhs: ref __arg_0, rhs: ref __arg_1, op: ref __arg_2 } => {
                    ExprKind::Logical{lhs: __arg_0.clone(),
                                      rhs: __arg_1.clone(),
                                      op: __arg_2.clone(),}
                }
                ExprKind::Unary { rhs: ref __arg_0, op: ref __arg_1 } => {
                    ExprKind::Unary{rhs: __arg_0.clone(),
                                    op: __arg_1.clone(),}
                }
                ExprKind::Struct { name: ref __arg_0, members: ref __arg_1 }
                => {
                    ExprKind::Struct{name: __arg_0.clone(),
                                     members: __arg_1.clone(),}
                }
                ExprKind::Tup(ref __arg_0) => {
                    ExprKind::Tup(__arg_0.clone())
                }
                ExprKind::Path(ref __arg_0) => {
                    ExprKind::Path(__arg_0.clone())
                }
                ExprKind::Index { callee: ref __arg_0, index: ref __arg_1 } =>
                {
                    ExprKind::Index{callee: __arg_0.clone(),
                                    index: __arg_1.clone(),}
                }
                ExprKind::Array(ref __arg_0) => {
                    ExprKind::Array(__arg_0.clone())
                }
                ExprKind::Range(ref __arg_0, ref __arg_1) => {
                    ExprKind::Range(__arg_0.clone(), __arg_1.clone())
                }
                ExprKind::Lit(ref __arg_0) => {
                    ExprKind::Lit(__arg_0.clone())
                }
                ExprKind::Field(ref __arg_0, ref __arg_1) => {
                    ExprKind::Field(__arg_0.clone(), __arg_1.clone())
                }
                ExprKind::This => { ExprKind::This }
                ExprKind::Val(ref __arg_0) => {
                    ExprKind::Val(__arg_0.clone())
                }
                ExprKind::Intrinsic { kind: ref __arg_0, args: ref __arg_1 }
                => {
                    ExprKind::Intrinsic{kind: __arg_0.clone(),
                                        args: __arg_1.clone(),}
                }
                ExprKind::Call { callee: ref __arg_0, args: ref __arg_1 } => {
                    ExprKind::Call{callee: __arg_0.clone(),
                                   args: __arg_1.clone(),}
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ExprKind {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ExprKind::Binary {
                lhs: ref __arg_0, rhs: ref __arg_1, op: ref __arg_2 } => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("Binary");
                    let _ = __debug_trait_builder.field("lhs", &__arg_0);
                    let _ = __debug_trait_builder.field("rhs", &__arg_1);
                    let _ = __debug_trait_builder.field("op", &__arg_2);
                    __debug_trait_builder.finish()
                }
                ExprKind::Logical {
                lhs: ref __arg_0, rhs: ref __arg_1, op: ref __arg_2 } => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("Logical");
                    let _ = __debug_trait_builder.field("lhs", &__arg_0);
                    let _ = __debug_trait_builder.field("rhs", &__arg_1);
                    let _ = __debug_trait_builder.field("op", &__arg_2);
                    __debug_trait_builder.finish()
                }
                ExprKind::Unary { rhs: ref __arg_0, op: ref __arg_1 } => {
                    let mut __debug_trait_builder = __f.debug_struct("Unary");
                    let _ = __debug_trait_builder.field("rhs", &__arg_0);
                    let _ = __debug_trait_builder.field("op", &__arg_1);
                    __debug_trait_builder.finish()
                }
                ExprKind::Struct { name: ref __arg_0, members: ref __arg_1 }
                => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("Struct");
                    let _ = __debug_trait_builder.field("name", &__arg_0);
                    let _ = __debug_trait_builder.field("members", &__arg_1);
                    __debug_trait_builder.finish()
                }
                ExprKind::Tup(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                ExprKind::Path(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                ExprKind::Index { callee: ref __arg_0, index: ref __arg_1 } =>
                {
                    let mut __debug_trait_builder = __f.debug_struct("Index");
                    let _ = __debug_trait_builder.field("callee", &__arg_0);
                    let _ = __debug_trait_builder.field("index", &__arg_1);
                    __debug_trait_builder.finish()
                }
                ExprKind::Array(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                ExprKind::Range(ref __arg_0, ref __arg_1) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Range");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    let _ = __debug_trait_builder.field(&__arg_1);
                    __debug_trait_builder.finish()
                }
                ExprKind::Lit(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                ExprKind::Field(ref __arg_0, ref __arg_1) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Field");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    let _ = __debug_trait_builder.field(&__arg_1);
                    __debug_trait_builder.finish()
                }
                ExprKind::This => {
                    let mut __debug_trait_builder = __f.debug_tuple("This");
                    __debug_trait_builder.finish()
                }
                ExprKind::Val(ref __arg_0) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Val");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    __debug_trait_builder.finish()
                }
                ExprKind::Intrinsic { kind: ref __arg_0, args: ref __arg_1 }
                => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("Intrinsic");
                    let _ = __debug_trait_builder.field("kind", &__arg_0);
                    let _ = __debug_trait_builder.field("args", &__arg_1);
                    __debug_trait_builder.finish()
                }
                ExprKind::Call { callee: ref __arg_0, args: ref __arg_1 } => {
                    let mut __debug_trait_builder = __f.debug_struct("Call");
                    let _ = __debug_trait_builder.field("callee", &__arg_0);
                    let _ = __debug_trait_builder.field("args", &__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ExprKind {
        fn eq(&self, other: &Self) -> bool {
            (::std::mem::discriminant(&*self) ==
                 ::std::mem::discriminant(&*other)) &&
                match (&*self, &*other) {
                    (ExprKind::Binary {
                     lhs: ref __self_0, rhs: ref __self_1, op: ref __self_2 },
                     ExprKind::Binary {
                     lhs: ref __other_0, rhs: ref __other_1, op: ref __other_2
                     }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2
                    }
                    (ExprKind::Logical {
                     lhs: ref __self_0, rhs: ref __self_1, op: ref __self_2 },
                     ExprKind::Logical {
                     lhs: ref __other_0, rhs: ref __other_1, op: ref __other_2
                     }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2
                    }
                    (ExprKind::Unary { rhs: ref __self_0, op: ref __self_1 },
                     ExprKind::Unary { rhs: ref __other_0, op: ref __other_1
                     }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    (ExprKind::Struct {
                     name: ref __self_0, members: ref __self_1 },
                     ExprKind::Struct {
                     name: ref __other_0, members: ref __other_1 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    (ExprKind::Tup(ref __self_0),
                     ExprKind::Tup(ref __other_0)) => {
                        true && __self_0 == __other_0
                    }
                    (ExprKind::Path(ref __self_0),
                     ExprKind::Path(ref __other_0)) => {
                        true && __self_0 == __other_0
                    }
                    (ExprKind::Index {
                     callee: ref __self_0, index: ref __self_1 },
                     ExprKind::Index {
                     callee: ref __other_0, index: ref __other_1 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    (ExprKind::Array(ref __self_0),
                     ExprKind::Array(ref __other_0)) => {
                        true && __self_0 == __other_0
                    }
                    (ExprKind::Range(ref __self_0, ref __self_1),
                     ExprKind::Range(ref __other_0, ref __other_1)) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    (ExprKind::Lit(ref __self_0),
                     ExprKind::Lit(ref __other_0)) => {
                        true && __self_0 == __other_0
                    }
                    (ExprKind::Field(ref __self_0, ref __self_1),
                     ExprKind::Field(ref __other_0, ref __other_1)) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    (ExprKind::This, ExprKind::This) => { true }
                    (ExprKind::Val(ref __self_0),
                     ExprKind::Val(ref __other_0)) => {
                        true && __self_0 == __other_0
                    }
                    (ExprKind::Intrinsic {
                     kind: ref __self_0, args: ref __self_1 },
                     ExprKind::Intrinsic {
                     kind: ref __other_0, args: ref __other_1 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    (ExprKind::Call { callee: ref __self_0, args: ref __self_1
                     }, ExprKind::Call {
                     callee: ref __other_0, args: ref __other_1 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    pub enum Intrinsic { Read, Write, Print, }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Intrinsic {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Intrinsic::Read,) => {
                    let mut debug_trait_builder = f.debug_tuple("Read");
                    debug_trait_builder.finish()
                }
                (&Intrinsic::Write,) => {
                    let mut debug_trait_builder = f.debug_tuple("Write");
                    debug_trait_builder.finish()
                }
                (&Intrinsic::Print,) => {
                    let mut debug_trait_builder = f.debug_tuple("Print");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Intrinsic { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Intrinsic {
        #[inline]
        fn clone(&self) -> Intrinsic { { *self } }
    }
    impl ::core::marker::StructuralPartialEq for Intrinsic { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Intrinsic {
        #[inline]
        fn eq(&self, other: &Intrinsic) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    #[derivative(Debug)]
    pub struct Member {
        pub name: Ident,
        pub init: Expr,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Member {
        #[inline]
        fn clone(&self) -> Member {
            match *self {
                Member {
                name: ref __self_0_0,
                init: ref __self_0_1,
                span: ref __self_0_2 } =>
                Member{name: ::core::clone::Clone::clone(&(*__self_0_0)),
                       init: ::core::clone::Clone::clone(&(*__self_0_1)),
                       span: ::core::clone::Clone::clone(&(*__self_0_2)),},
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Member { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Member {
        #[inline]
        fn eq(&self, other: &Member) -> bool {
            match *other {
                Member {
                name: ref __self_1_0,
                init: ref __self_1_1,
                span: ref __self_1_2 } =>
                match *self {
                    Member {
                    name: ref __self_0_0,
                    init: ref __self_0_1,
                    span: ref __self_0_2 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Member) -> bool {
            match *other {
                Member {
                name: ref __self_1_0,
                init: ref __self_1_1,
                span: ref __self_1_2 } =>
                match *self {
                    Member {
                    name: ref __self_0_0,
                    init: ref __self_0_1,
                    span: ref __self_0_2 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2),
                },
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Member {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Member {
                name: ref __arg_0, init: ref __arg_1, span: ref __arg_2 } => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("Member");
                    let _ = __debug_trait_builder.field("name", &__arg_0);
                    let _ = __debug_trait_builder.field("init", &__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    impl Member {
        pub fn new(name: Ident, expr: Expr, span: Span) -> Self {
            Self{name, init: expr, span,}
        }
    }
    #[derivative(Debug)]
    pub struct Struct {
        pub name: Ident,
        pub fields: Vec<Field>,
        pub methods: Vec<FnDecl>,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Struct {
        #[inline]
        fn clone(&self) -> Struct {
            match *self {
                Struct {
                name: ref __self_0_0,
                fields: ref __self_0_1,
                methods: ref __self_0_2,
                span: ref __self_0_3 } =>
                Struct{name: ::core::clone::Clone::clone(&(*__self_0_0)),
                       fields: ::core::clone::Clone::clone(&(*__self_0_1)),
                       methods: ::core::clone::Clone::clone(&(*__self_0_2)),
                       span: ::core::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Struct { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Struct {
        #[inline]
        fn eq(&self, other: &Struct) -> bool {
            match *other {
                Struct {
                name: ref __self_1_0,
                fields: ref __self_1_1,
                methods: ref __self_1_2,
                span: ref __self_1_3 } =>
                match *self {
                    Struct {
                    name: ref __self_0_0,
                    fields: ref __self_0_1,
                    methods: ref __self_0_2,
                    span: ref __self_0_3 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Struct) -> bool {
            match *other {
                Struct {
                name: ref __self_1_0,
                fields: ref __self_1_1,
                methods: ref __self_1_2,
                span: ref __self_1_3 } =>
                match *self {
                    Struct {
                    name: ref __self_0_0,
                    fields: ref __self_0_1,
                    methods: ref __self_0_2,
                    span: ref __self_0_3 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3),
                },
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Struct {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Struct {
                name: ref __arg_0,
                fields: ref __arg_1,
                methods: ref __arg_2,
                span: ref __arg_3 } => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("Struct");
                    let _ = __debug_trait_builder.field("name", &__arg_0);
                    let _ = __debug_trait_builder.field("fields", &__arg_1);
                    let _ = __debug_trait_builder.field("methods", &__arg_2);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[derivative(Debug)]
    pub struct Enum {
        pub name: Ident,
        pub variants: Vec<Variant>,
        pub methods: Vec<FnDecl>,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Enum {
        #[inline]
        fn clone(&self) -> Enum {
            match *self {
                Enum {
                name: ref __self_0_0,
                variants: ref __self_0_1,
                methods: ref __self_0_2,
                span: ref __self_0_3 } =>
                Enum{name: ::core::clone::Clone::clone(&(*__self_0_0)),
                     variants: ::core::clone::Clone::clone(&(*__self_0_1)),
                     methods: ::core::clone::Clone::clone(&(*__self_0_2)),
                     span: ::core::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Enum { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Enum {
        #[inline]
        fn eq(&self, other: &Enum) -> bool {
            match *other {
                Enum {
                name: ref __self_1_0,
                variants: ref __self_1_1,
                methods: ref __self_1_2,
                span: ref __self_1_3 } =>
                match *self {
                    Enum {
                    name: ref __self_0_0,
                    variants: ref __self_0_1,
                    methods: ref __self_0_2,
                    span: ref __self_0_3 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Enum) -> bool {
            match *other {
                Enum {
                name: ref __self_1_0,
                variants: ref __self_1_1,
                methods: ref __self_1_2,
                span: ref __self_1_3 } =>
                match *self {
                    Enum {
                    name: ref __self_0_0,
                    variants: ref __self_0_1,
                    methods: ref __self_0_2,
                    span: ref __self_0_3 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3),
                },
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Enum {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Enum {
                name: ref __arg_0,
                variants: ref __arg_1,
                methods: ref __arg_2,
                span: ref __arg_3 } => {
                    let mut __debug_trait_builder = __f.debug_struct("Enum");
                    let _ = __debug_trait_builder.field("name", &__arg_0);
                    let _ = __debug_trait_builder.field("variants", &__arg_1);
                    let _ = __debug_trait_builder.field("methods", &__arg_2);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[derivative(Debug)]
    pub enum TyDecl { Struct(Struct), Enum(Enum), }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TyDecl {
        #[inline]
        fn clone(&self) -> TyDecl {
            match (&*self,) {
                (&TyDecl::Struct(ref __self_0),) =>
                TyDecl::Struct(::core::clone::Clone::clone(&(*__self_0))),
                (&TyDecl::Enum(ref __self_0),) =>
                TyDecl::Enum(::core::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TyDecl { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TyDecl {
        #[inline]
        fn eq(&self, other: &TyDecl) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TyDecl::Struct(ref __self_0),
                         &TyDecl::Struct(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&TyDecl::Enum(ref __self_0),
                         &TyDecl::Enum(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &TyDecl) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TyDecl::Struct(ref __self_0),
                         &TyDecl::Struct(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&TyDecl::Enum(ref __self_0),
                         &TyDecl::Enum(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for TyDecl {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                TyDecl::Struct(ref __arg_0) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Struct");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    __debug_trait_builder.finish()
                }
                TyDecl::Enum(ref __arg_0) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Enum");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    impl TyDecl {
        pub fn name(&self) -> Ident {
            match self {
                TyDecl::Enum(e) => e.name.clone(),
                TyDecl::Struct(s) => s.name.clone(),
            }
        }
        pub fn add_methods(&mut self, mut methods: Vec<FnDecl>) {
            match self {
                TyDecl::Enum(e) => e.methods.append(&mut methods),
                TyDecl::Struct(s) => s.methods.append(&mut methods),
            }
        }
        pub fn get_method(&self, name: &str) {
            { ::std::rt::begin_panic("not yet implemented") };
        }
    }
    #[derivative(Debug)]
    pub struct FnDecl {
        pub header: FnSig,
        pub body: Block,
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FnDecl {
        #[inline]
        fn clone(&self) -> FnDecl {
            match *self {
                FnDecl {
                header: ref __self_0_0,
                body: ref __self_0_1,
                span: ref __self_0_2 } =>
                FnDecl{header: ::core::clone::Clone::clone(&(*__self_0_0)),
                       body: ::core::clone::Clone::clone(&(*__self_0_1)),
                       span: ::core::clone::Clone::clone(&(*__self_0_2)),},
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FnDecl { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FnDecl {
        #[inline]
        fn eq(&self, other: &FnDecl) -> bool {
            match *other {
                FnDecl {
                header: ref __self_1_0,
                body: ref __self_1_1,
                span: ref __self_1_2 } =>
                match *self {
                    FnDecl {
                    header: ref __self_0_0,
                    body: ref __self_0_1,
                    span: ref __self_0_2 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FnDecl) -> bool {
            match *other {
                FnDecl {
                header: ref __self_1_0,
                body: ref __self_1_1,
                span: ref __self_1_2 } =>
                match *self {
                    FnDecl {
                    header: ref __self_0_0,
                    body: ref __self_0_1,
                    span: ref __self_0_2 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2),
                },
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FnDecl {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FnDecl {
                header: ref __arg_0, body: ref __arg_1, span: ref __arg_2 } =>
                {
                    let mut __debug_trait_builder =
                        __f.debug_struct("FnDecl");
                    let _ = __debug_trait_builder.field("header", &__arg_0);
                    let _ = __debug_trait_builder.field("body", &__arg_1);
                    let _ = __debug_trait_builder.field("span", &__arg_2);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[derivative(Debug)]
    pub enum Decl {
        TyDecl(TyDecl),
        Fn(FnDecl),
        Impl {
            target: Path,
            fn_decls: Vec<FnDecl>,
            #[derivative(Debug = "ignore")]
            span: Span,
        },
    }
    impl ::core::marker::StructuralPartialEq for Decl { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Decl {
        #[inline]
        fn eq(&self, other: &Decl) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Decl::TyDecl(ref __self_0),
                         &Decl::TyDecl(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Decl::Fn(ref __self_0), &Decl::Fn(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Decl::Impl {
                         target: ref __self_0,
                         fn_decls: ref __self_1,
                         span: ref __self_2 }, &Decl::Impl {
                         target: ref __arg_1_0,
                         fn_decls: ref __arg_1_1,
                         span: ref __arg_1_2 }) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1) &&
                            (*__self_2) == (*__arg_1_2),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &Decl) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Decl::TyDecl(ref __self_0),
                         &Decl::TyDecl(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Decl::Fn(ref __self_0), &Decl::Fn(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Decl::Impl {
                         target: ref __self_0,
                         fn_decls: ref __self_1,
                         span: ref __self_2 }, &Decl::Impl {
                         target: ref __arg_1_0,
                         fn_decls: ref __arg_1_1,
                         span: ref __arg_1_2 }) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1) ||
                            (*__self_2) != (*__arg_1_2),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Decl {
        #[inline]
        fn clone(&self) -> Decl {
            match (&*self,) {
                (&Decl::TyDecl(ref __self_0),) =>
                Decl::TyDecl(::core::clone::Clone::clone(&(*__self_0))),
                (&Decl::Fn(ref __self_0),) =>
                Decl::Fn(::core::clone::Clone::clone(&(*__self_0))),
                (&Decl::Impl {
                 target: ref __self_0,
                 fn_decls: ref __self_1,
                 span: ref __self_2 },) =>
                Decl::Impl{target: ::core::clone::Clone::clone(&(*__self_0)),
                           fn_decls:
                               ::core::clone::Clone::clone(&(*__self_1)),
                           span: ::core::clone::Clone::clone(&(*__self_2)),},
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Decl {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Decl::TyDecl(ref __arg_0) => {
                    let mut __debug_trait_builder = __f.debug_tuple("TyDecl");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    __debug_trait_builder.finish()
                }
                Decl::Fn(ref __arg_0) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Fn");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    __debug_trait_builder.finish()
                }
                Decl::Impl {
                target: ref __arg_0, fn_decls: ref __arg_1, span: ref __arg_2
                } => {
                    let mut __debug_trait_builder = __f.debug_struct("Impl");
                    let _ = __debug_trait_builder.field("target", &__arg_0);
                    let _ = __debug_trait_builder.field("fn_decls", &__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[derivative(Debug)]
    pub enum Stmt {
        Expr(Expr),

        #[derivative(Debug = "transparent")]
        VarDef(VarDef),

        /// An assignment stmt can be used to change the value of an already defined variable
        /// NOTE: it's type is fixed and must be equal on both sides
        /// example: a.b    = 20
        ///          ^-callee ^value
        Assign {
            lhs: Expr,
            rhs: Expr,
            span: Span,
        },

        #[derivative(Debug = "transparent")]
        Block(Block),
        If {
            cond: Expr,
            body: Block,
            else_branches: Vec<ElseBranch>,
            final_branch: Option<FinalBranch>,
            #[derivative(Debug = "ignore")]
            span: Span,
        },
        While {
            cond: Expr,
            body: Block,
            #[derivative(Debug = "ignore")]
            span: Span,
        },
        For {
            vardef: VarDef,
            body: Block,
            #[derivative(Debug = "ignore")]
            span: Span,
        },
        Break(Span),
        Continue(Span),
        Ret(Expr, Span),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Stmt {
        #[inline]
        fn clone(&self) -> Stmt {
            match (&*self,) {
                (&Stmt::Expr(ref __self_0),) =>
                Stmt::Expr(::core::clone::Clone::clone(&(*__self_0))),
                (&Stmt::VarDef(ref __self_0),) =>
                Stmt::VarDef(::core::clone::Clone::clone(&(*__self_0))),
                (&Stmt::Assign {
                 lhs: ref __self_0, rhs: ref __self_1, span: ref __self_2 },)
                =>
                Stmt::Assign{lhs: ::core::clone::Clone::clone(&(*__self_0)),
                             rhs: ::core::clone::Clone::clone(&(*__self_1)),
                             span:
                                 ::core::clone::Clone::clone(&(*__self_2)),},
                (&Stmt::Block(ref __self_0),) =>
                Stmt::Block(::core::clone::Clone::clone(&(*__self_0))),
                (&Stmt::If {
                 cond: ref __self_0,
                 body: ref __self_1,
                 else_branches: ref __self_2,
                 final_branch: ref __self_3,
                 span: ref __self_4 },) =>
                Stmt::If{cond: ::core::clone::Clone::clone(&(*__self_0)),
                         body: ::core::clone::Clone::clone(&(*__self_1)),
                         else_branches:
                             ::core::clone::Clone::clone(&(*__self_2)),
                         final_branch:
                             ::core::clone::Clone::clone(&(*__self_3)),
                         span: ::core::clone::Clone::clone(&(*__self_4)),},
                (&Stmt::While {
                 cond: ref __self_0, body: ref __self_1, span: ref __self_2
                 },) =>
                Stmt::While{cond: ::core::clone::Clone::clone(&(*__self_0)),
                            body: ::core::clone::Clone::clone(&(*__self_1)),
                            span: ::core::clone::Clone::clone(&(*__self_2)),},
                (&Stmt::For {
                 vardef: ref __self_0, body: ref __self_1, span: ref __self_2
                 },) =>
                Stmt::For{vardef: ::core::clone::Clone::clone(&(*__self_0)),
                          body: ::core::clone::Clone::clone(&(*__self_1)),
                          span: ::core::clone::Clone::clone(&(*__self_2)),},
                (&Stmt::Break(ref __self_0),) =>
                Stmt::Break(::core::clone::Clone::clone(&(*__self_0))),
                (&Stmt::Continue(ref __self_0),) =>
                Stmt::Continue(::core::clone::Clone::clone(&(*__self_0))),
                (&Stmt::Ret(ref __self_0, ref __self_1),) =>
                Stmt::Ret(::core::clone::Clone::clone(&(*__self_0)),
                          ::core::clone::Clone::clone(&(*__self_1))),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Stmt { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Stmt {
        #[inline]
        fn eq(&self, other: &Stmt) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Stmt::Expr(ref __self_0),
                         &Stmt::Expr(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Stmt::VarDef(ref __self_0),
                         &Stmt::VarDef(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Stmt::Assign {
                         lhs: ref __self_0,
                         rhs: ref __self_1,
                         span: ref __self_2 }, &Stmt::Assign {
                         lhs: ref __arg_1_0,
                         rhs: ref __arg_1_1,
                         span: ref __arg_1_2 }) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1) &&
                            (*__self_2) == (*__arg_1_2),
                        (&Stmt::Block(ref __self_0),
                         &Stmt::Block(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Stmt::If {
                         cond: ref __self_0,
                         body: ref __self_1,
                         else_branches: ref __self_2,
                         final_branch: ref __self_3,
                         span: ref __self_4 }, &Stmt::If {
                         cond: ref __arg_1_0,
                         body: ref __arg_1_1,
                         else_branches: ref __arg_1_2,
                         final_branch: ref __arg_1_3,
                         span: ref __arg_1_4 }) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1) &&
                            (*__self_2) == (*__arg_1_2) &&
                            (*__self_3) == (*__arg_1_3) &&
                            (*__self_4) == (*__arg_1_4),
                        (&Stmt::While {
                         cond: ref __self_0,
                         body: ref __self_1,
                         span: ref __self_2 }, &Stmt::While {
                         cond: ref __arg_1_0,
                         body: ref __arg_1_1,
                         span: ref __arg_1_2 }) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1) &&
                            (*__self_2) == (*__arg_1_2),
                        (&Stmt::For {
                         vardef: ref __self_0,
                         body: ref __self_1,
                         span: ref __self_2 }, &Stmt::For {
                         vardef: ref __arg_1_0,
                         body: ref __arg_1_1,
                         span: ref __arg_1_2 }) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1) &&
                            (*__self_2) == (*__arg_1_2),
                        (&Stmt::Break(ref __self_0),
                         &Stmt::Break(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Stmt::Continue(ref __self_0),
                         &Stmt::Continue(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Stmt::Ret(ref __self_0, ref __self_1),
                         &Stmt::Ret(ref __arg_1_0, ref __arg_1_1)) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &Stmt) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Stmt::Expr(ref __self_0),
                         &Stmt::Expr(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Stmt::VarDef(ref __self_0),
                         &Stmt::VarDef(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Stmt::Assign {
                         lhs: ref __self_0,
                         rhs: ref __self_1,
                         span: ref __self_2 }, &Stmt::Assign {
                         lhs: ref __arg_1_0,
                         rhs: ref __arg_1_1,
                         span: ref __arg_1_2 }) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1) ||
                            (*__self_2) != (*__arg_1_2),
                        (&Stmt::Block(ref __self_0),
                         &Stmt::Block(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Stmt::If {
                         cond: ref __self_0,
                         body: ref __self_1,
                         else_branches: ref __self_2,
                         final_branch: ref __self_3,
                         span: ref __self_4 }, &Stmt::If {
                         cond: ref __arg_1_0,
                         body: ref __arg_1_1,
                         else_branches: ref __arg_1_2,
                         final_branch: ref __arg_1_3,
                         span: ref __arg_1_4 }) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1) ||
                            (*__self_2) != (*__arg_1_2) ||
                            (*__self_3) != (*__arg_1_3) ||
                            (*__self_4) != (*__arg_1_4),
                        (&Stmt::While {
                         cond: ref __self_0,
                         body: ref __self_1,
                         span: ref __self_2 }, &Stmt::While {
                         cond: ref __arg_1_0,
                         body: ref __arg_1_1,
                         span: ref __arg_1_2 }) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1) ||
                            (*__self_2) != (*__arg_1_2),
                        (&Stmt::For {
                         vardef: ref __self_0,
                         body: ref __self_1,
                         span: ref __self_2 }, &Stmt::For {
                         vardef: ref __arg_1_0,
                         body: ref __arg_1_1,
                         span: ref __arg_1_2 }) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1) ||
                            (*__self_2) != (*__arg_1_2),
                        (&Stmt::Break(ref __self_0),
                         &Stmt::Break(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Stmt::Continue(ref __self_0),
                         &Stmt::Continue(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Stmt::Ret(ref __self_0, ref __self_1),
                         &Stmt::Ret(ref __arg_1_0, ref __arg_1_1)) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Stmt {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Stmt::Expr(ref __arg_0) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Expr");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    __debug_trait_builder.finish()
                }
                Stmt::VarDef(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                Stmt::Assign {
                lhs: ref __arg_0, rhs: ref __arg_1, span: ref __arg_2 } => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("Assign");
                    let _ = __debug_trait_builder.field("lhs", &__arg_0);
                    let _ = __debug_trait_builder.field("rhs", &__arg_1);
                    let _ = __debug_trait_builder.field("span", &__arg_2);
                    __debug_trait_builder.finish()
                }
                Stmt::Block(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                Stmt::If {
                cond: ref __arg_0,
                body: ref __arg_1,
                else_branches: ref __arg_2,
                final_branch: ref __arg_3,
                span: ref __arg_4 } => {
                    let mut __debug_trait_builder = __f.debug_struct("If");
                    let _ = __debug_trait_builder.field("cond", &__arg_0);
                    let _ = __debug_trait_builder.field("body", &__arg_1);
                    let _ =
                        __debug_trait_builder.field("else_branches",
                                                    &__arg_2);
                    let _ =
                        __debug_trait_builder.field("final_branch", &__arg_3);
                    __debug_trait_builder.finish()
                }
                Stmt::While {
                cond: ref __arg_0, body: ref __arg_1, span: ref __arg_2 } => {
                    let mut __debug_trait_builder = __f.debug_struct("While");
                    let _ = __debug_trait_builder.field("cond", &__arg_0);
                    let _ = __debug_trait_builder.field("body", &__arg_1);
                    __debug_trait_builder.finish()
                }
                Stmt::For {
                vardef: ref __arg_0, body: ref __arg_1, span: ref __arg_2 } =>
                {
                    let mut __debug_trait_builder = __f.debug_struct("For");
                    let _ = __debug_trait_builder.field("vardef", &__arg_0);
                    let _ = __debug_trait_builder.field("body", &__arg_1);
                    __debug_trait_builder.finish()
                }
                Stmt::Break(ref __arg_0) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Break");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    __debug_trait_builder.finish()
                }
                Stmt::Continue(ref __arg_0) => {
                    let mut __debug_trait_builder =
                        __f.debug_tuple("Continue");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    __debug_trait_builder.finish()
                }
                Stmt::Ret(ref __arg_0, ref __arg_1) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Ret");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    let _ = __debug_trait_builder.field(&__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[derivative(Debug, PartialEq)]
    pub struct VarDef {
        pub pat: Ident,
        pub ty: Ty,
        pub init: Expr,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for VarDef {
        #[inline]
        fn clone(&self) -> VarDef {
            match *self {
                VarDef {
                pat: ref __self_0_0,
                ty: ref __self_0_1,
                init: ref __self_0_2,
                span: ref __self_0_3 } =>
                VarDef{pat: ::core::clone::Clone::clone(&(*__self_0_0)),
                       ty: ::core::clone::Clone::clone(&(*__self_0_1)),
                       init: ::core::clone::Clone::clone(&(*__self_0_2)),
                       span: ::core::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for VarDef {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                VarDef {
                pat: ref __arg_0,
                ty: ref __arg_1,
                init: ref __arg_2,
                span: ref __arg_3 } => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("VarDef");
                    let _ = __debug_trait_builder.field("pat", &__arg_0);
                    let _ = __debug_trait_builder.field("ty", &__arg_1);
                    let _ = __debug_trait_builder.field("init", &__arg_2);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for VarDef {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (VarDef {
                     pat: ref __self_0,
                     ty: ref __self_1,
                     init: ref __self_2,
                     span: ref __self_3 }, VarDef {
                     pat: ref __other_0,
                     ty: ref __other_1,
                     init: ref __other_2,
                     span: ref __other_3 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2 && __self_3 == __other_3
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    #[derivative(Debug, PartialEq)]
    pub struct ElseBranch {
        pub cond: Expr,
        pub body: Block,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ElseBranch {
        #[inline]
        fn clone(&self) -> ElseBranch {
            match *self {
                ElseBranch {
                cond: ref __self_0_0,
                body: ref __self_0_1,
                span: ref __self_0_2 } =>
                ElseBranch{cond: ::core::clone::Clone::clone(&(*__self_0_0)),
                           body: ::core::clone::Clone::clone(&(*__self_0_1)),
                           span:
                               ::core::clone::Clone::clone(&(*__self_0_2)),},
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ElseBranch {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ElseBranch {
                cond: ref __arg_0, body: ref __arg_1, span: ref __arg_2 } => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("ElseBranch");
                    let _ = __debug_trait_builder.field("cond", &__arg_0);
                    let _ = __debug_trait_builder.field("body", &__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ElseBranch {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (ElseBranch {
                     cond: ref __self_0,
                     body: ref __self_1,
                     span: ref __self_2 }, ElseBranch {
                     cond: ref __other_0,
                     body: ref __other_1,
                     span: ref __other_2 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    #[derivative(Debug, PartialEq)]
    pub struct FinalBranch {
        pub body: Block,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FinalBranch {
        #[inline]
        fn clone(&self) -> FinalBranch {
            match *self {
                FinalBranch { body: ref __self_0_0, span: ref __self_0_1 } =>
                FinalBranch{body: ::core::clone::Clone::clone(&(*__self_0_0)),
                            span:
                                ::core::clone::Clone::clone(&(*__self_0_1)),},
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FinalBranch {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FinalBranch { body: ref __arg_0, span: ref __arg_1 } => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("FinalBranch");
                    let _ = __debug_trait_builder.field("body", &__arg_0);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FinalBranch {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (FinalBranch { body: ref __self_0, span: ref __self_1 },
                     FinalBranch { body: ref __other_0, span: ref __other_1 })
                    => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    impl ASTNode for Stmt {
        fn accept<V: Visitor>(&mut self, visitor: &mut V) -> V::Result {
            visitor.visit_stmt(self)
        }
    }
    #[derivative(Debug, PartialEq)]
    pub struct EnumDecl {
        pub ident: Ident,
        pub variants: Vec<Variant>,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for EnumDecl {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                EnumDecl {
                ident: ref __arg_0, variants: ref __arg_1, span: ref __arg_2 }
                => {
                    let mut __debug_trait_builder =
                        __f.debug_struct("EnumDecl");
                    let _ = __debug_trait_builder.field("ident", &__arg_0);
                    let _ = __debug_trait_builder.field("variants", &__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for EnumDecl {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (EnumDecl {
                     ident: ref __self_0,
                     variants: ref __self_1,
                     span: ref __self_2 }, EnumDecl {
                     ident: ref __other_0,
                     variants: ref __other_1,
                     span: ref __other_2 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    #[derivative(Debug, PartialEq)]
    pub struct Variant {
        pub ident: Ident,
        pub data: VariantData,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Variant {
        #[inline]
        fn clone(&self) -> Variant {
            match *self {
                Variant {
                ident: ref __self_0_0,
                data: ref __self_0_1,
                span: ref __self_0_2 } =>
                Variant{ident: ::core::clone::Clone::clone(&(*__self_0_0)),
                        data: ::core::clone::Clone::clone(&(*__self_0_1)),
                        span: ::core::clone::Clone::clone(&(*__self_0_2)),},
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Variant {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Variant {
                ident: ref __arg_0, data: ref __arg_1, span: ref __arg_2 } =>
                {
                    let mut __debug_trait_builder =
                        __f.debug_struct("Variant");
                    let _ = __debug_trait_builder.field("ident", &__arg_0);
                    let _ = __debug_trait_builder.field("data", &__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Variant {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (Variant {
                     ident: ref __self_0,
                     data: ref __self_1,
                     span: ref __self_2 }, Variant {
                     ident: ref __other_0,
                     data: ref __other_1,
                     span: ref __other_2 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    pub enum VariantData { Val(Vec<Ty>), Unit, }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for VariantData {
        #[inline]
        fn clone(&self) -> VariantData {
            match (&*self,) {
                (&VariantData::Val(ref __self_0),) =>
                VariantData::Val(::core::clone::Clone::clone(&(*__self_0))),
                (&VariantData::Unit,) => VariantData::Unit,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for VariantData {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&VariantData::Val(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Val");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&VariantData::Unit,) => {
                    let mut debug_trait_builder = f.debug_tuple("Unit");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for VariantData { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for VariantData {
        #[inline]
        fn eq(&self, other: &VariantData) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&VariantData::Val(ref __self_0),
                         &VariantData::Val(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &VariantData) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&VariantData::Val(ref __self_0),
                         &VariantData::Val(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else { true }
            }
        }
    }
    #[derivative(Debug, PartialEq, Clone)]
    pub struct Path {
        pub segments: Vec<Ident>,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Path {
        fn clone(&self) -> Self {
            match *self {
                Path { segments: ref __arg_0, span: ref __arg_1 } => {
                    Path{segments: __arg_0.clone(), span: __arg_1.clone(),}
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Path {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Path { segments: ref __arg_0, span: ref __arg_1 } => {
                    let mut __debug_trait_builder = __f.debug_struct("Path");
                    let _ = __debug_trait_builder.field("segments", &__arg_0);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Path {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (Path { segments: ref __self_0, span: ref __self_1 },
                     Path { segments: ref __other_0, span: ref __other_1 }) =>
                    {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    impl Path {
        pub fn new(segments: Vec<Ident>, span: Span) -> Self {
            Path{segments, span,}
        }
        pub fn first(&self) -> Option<&Ident> { self.segments.last() }
        pub fn len(&self) -> usize { self.segments.len() }
    }
    #[derivative(Debug, PartialEq)]
    pub struct Param {
        pub name: Ident,
        pub ty: Ty,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Param {
        #[inline]
        fn clone(&self) -> Param {
            match *self {
                Param {
                name: ref __self_0_0, ty: ref __self_0_1, span: ref __self_0_2
                } =>
                Param{name: ::core::clone::Clone::clone(&(*__self_0_0)),
                      ty: ::core::clone::Clone::clone(&(*__self_0_1)),
                      span: ::core::clone::Clone::clone(&(*__self_0_2)),},
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Param {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Param { name: ref __arg_0, ty: ref __arg_1, span: ref __arg_2
                } => {
                    let mut __debug_trait_builder = __f.debug_struct("Param");
                    let _ = __debug_trait_builder.field("name", &__arg_0);
                    let _ = __debug_trait_builder.field("ty", &__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Param {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (Param {
                     name: ref __self_0, ty: ref __self_1, span: ref __self_2
                     }, Param {
                     name: ref __other_0,
                     ty: ref __other_1,
                     span: ref __other_2 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    impl Param {
        pub fn new(name: Ident, ty: Ty, span: Span) -> Self {
            Self{name, ty, span,}
        }
    }
    impl Struct {
        pub fn add_methods(&mut self, mut methods: Vec<FnDecl>) {
            self.methods.append(&mut methods);
        }
    }
    #[derivative(Debug, PartialEq)]
    pub struct Field {
        pub name: Ident,
        pub ty: Ty,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Field {
        #[inline]
        fn clone(&self) -> Field {
            match *self {
                Field {
                name: ref __self_0_0, ty: ref __self_0_1, span: ref __self_0_2
                } =>
                Field{name: ::core::clone::Clone::clone(&(*__self_0_0)),
                      ty: ::core::clone::Clone::clone(&(*__self_0_1)),
                      span: ::core::clone::Clone::clone(&(*__self_0_2)),},
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Field {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Field { name: ref __arg_0, ty: ref __arg_1, span: ref __arg_2
                } => {
                    let mut __debug_trait_builder = __f.debug_struct("Field");
                    let _ = __debug_trait_builder.field("name", &__arg_0);
                    let _ = __debug_trait_builder.field("ty", &__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Field {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (Field {
                     name: ref __self_0, ty: ref __self_1, span: ref __self_2
                     }, Field {
                     name: ref __other_0,
                     ty: ref __other_1,
                     span: ref __other_2 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    #[derivative(Debug, PartialEq, Clone)]
    pub struct Ident {
        pub lexeme: String,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Ident {
        fn clone(&self) -> Self {
            match *self {
                Ident { lexeme: ref __arg_0, span: ref __arg_1 } => {
                    Ident{lexeme: __arg_0.clone(), span: __arg_1.clone(),}
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Ident {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Ident { lexeme: ref __arg_0, span: ref __arg_1 } => {
                    let mut __debug_trait_builder = __f.debug_struct("Ident");
                    let _ = __debug_trait_builder.field("lexeme", &__arg_0);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Ident {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (Ident { lexeme: ref __self_0, span: ref __self_1 },
                     Ident { lexeme: ref __other_0, span: ref __other_1 }) =>
                    {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    impl TryFrom<Token> for Ident {
        type Error = Diagnostic;
        fn try_from(t: Token) -> Result<Ident, Self::Error> {
            match t.kind {
                TokenKind::Ident(name) => Ok(Ident::new(name, t.span)),
                _ =>
                Err(Diagnostic::new(ErrKind::Internal({
                                                          let res =
                                                              ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(&["Invalide Umwandlung von Token ",
                                                                                                                              " zu Ident"],
                                                                                                                            &match (&t,)
                                                                                                                                 {
                                                                                                                                 (arg0,)
                                                                                                                                 =>
                                                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                               ::core::fmt::Debug::fmt)],
                                                                                                                             },
                                                                                                                            &[::core::fmt::rt::v1::Argument{position:
                                                                                                                                                                0usize,
                                                                                                                                                            format:
                                                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                    ' ',
                                                                                                                                                                                                align:
                                                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                flags:
                                                                                                                                                                                                    4u32,
                                                                                                                                                                                                precision:
                                                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                width:
                                                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},}]));
                                                          res
                                                      }), Vec::new(),
                                    t.span)),
            }
        }
    }
    impl Ident {
        pub fn new(name: String, span: Span) -> Self {
            Ident{lexeme: name, span,}
        }
    }
    impl Field {
        pub fn new(name: Ident, ty: Ty, span: Span) -> Self {
            Field{name, ty, span,}
        }
    }
    #[derivative(Debug, PartialEq)]
    pub struct FnSig {
        pub name: Ident,
        pub params: Vec<Param>,
        pub ret_ty: Ty,
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FnSig {
        #[inline]
        fn clone(&self) -> FnSig {
            match *self {
                FnSig {
                name: ref __self_0_0,
                params: ref __self_0_1,
                ret_ty: ref __self_0_2,
                span: ref __self_0_3 } =>
                FnSig{name: ::core::clone::Clone::clone(&(*__self_0_0)),
                      params: ::core::clone::Clone::clone(&(*__self_0_1)),
                      ret_ty: ::core::clone::Clone::clone(&(*__self_0_2)),
                      span: ::core::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FnSig {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FnSig {
                name: ref __arg_0,
                params: ref __arg_1,
                ret_ty: ref __arg_2,
                span: ref __arg_3 } => {
                    let mut __debug_trait_builder = __f.debug_struct("FnSig");
                    let _ = __debug_trait_builder.field("name", &__arg_0);
                    let _ = __debug_trait_builder.field("params", &__arg_1);
                    let _ = __debug_trait_builder.field("ret_ty", &__arg_2);
                    let _ = __debug_trait_builder.field("span", &__arg_3);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FnSig {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (FnSig {
                     name: ref __self_0,
                     params: ref __self_1,
                     ret_ty: ref __self_2,
                     span: ref __self_3 }, FnSig {
                     name: ref __other_0,
                     params: ref __other_1,
                     ret_ty: ref __other_2,
                     span: ref __other_3 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2 && __self_3 == __other_3
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    #[derivative(Debug, PartialEq)]
    pub struct Block {
        pub stmts: Vec<Stmt>,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Block {
        #[inline]
        fn clone(&self) -> Block {
            match *self {
                Block { stmts: ref __self_0_0, span: ref __self_0_1 } =>
                Block{stmts: ::core::clone::Clone::clone(&(*__self_0_0)),
                      span: ::core::clone::Clone::clone(&(*__self_0_1)),},
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Block {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Block { stmts: ref __arg_0, span: ref __arg_1 } => {
                    let mut __debug_trait_builder = __f.debug_struct("Block");
                    let _ = __debug_trait_builder.field("stmts", &__arg_0);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Block {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (Block { stmts: ref __self_0, span: ref __self_1 },
                     Block { stmts: ref __other_0, span: ref __other_1 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    impl Block {
        pub fn new(stmts: Vec<Stmt>, span: Span) -> Self {
            Block{stmts, span,}
        }
    }
    impl Default for ExprKind {
        fn default() -> Self { ExprKind::Tup(Vec::new()) }
    }
    #[derivative(Debug, PartialEq, Clone)]
    pub struct Expr {
        pub node: ExprKind,
        pub ty: Ty,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Expr {
        fn clone(&self) -> Self {
            match *self {
                Expr { node: ref __arg_0, ty: ref __arg_1, span: ref __arg_2 }
                => {
                    Expr{node: __arg_0.clone(),
                         ty: __arg_1.clone(),
                         span: __arg_2.clone(),}
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Expr {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Expr { node: ref __arg_0, ty: ref __arg_1, span: ref __arg_2 }
                => {
                    let mut __debug_trait_builder = __f.debug_struct("Expr");
                    let _ = __debug_trait_builder.field("node", &__arg_0);
                    let _ = __debug_trait_builder.field("ty", &__arg_1);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Expr {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (Expr {
                     node: ref __self_0, ty: ref __self_1, span: ref __self_2
                     }, Expr {
                     node: ref __other_0,
                     ty: ref __other_1,
                     span: ref __other_2 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                            && __self_2 == __other_2
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    impl ASTNode for Expr {
        fn accept<V: Visitor>(&mut self, visitor: &mut V) -> V::Result {
            visitor.visit_expr(self)
        }
    }
    impl Expr {
        pub fn new(node: ExprKind, span: Span) -> Self {
            Self{node, span, ty: Ty{kind: TyKind::Infer, span,},}
        }
        pub fn empty(span: Span) -> Self {
            Self{node: ExprKind::Tup(Vec::new()),
                 span,
                 ty: Ty{kind: TyKind::Tup(Vec::new()), span,},}
        }
    }
    pub enum BinaryOp { Plus, Minus, Multiply, Divide, }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BinaryOp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&BinaryOp::Plus,) => {
                    let mut debug_trait_builder = f.debug_tuple("Plus");
                    debug_trait_builder.finish()
                }
                (&BinaryOp::Minus,) => {
                    let mut debug_trait_builder = f.debug_tuple("Minus");
                    debug_trait_builder.finish()
                }
                (&BinaryOp::Multiply,) => {
                    let mut debug_trait_builder = f.debug_tuple("Multiply");
                    debug_trait_builder.finish()
                }
                (&BinaryOp::Divide,) => {
                    let mut debug_trait_builder = f.debug_tuple("Divide");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for BinaryOp { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for BinaryOp {
        #[inline]
        fn eq(&self, other: &BinaryOp) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for BinaryOp {
        #[inline]
        fn clone(&self) -> BinaryOp { { *self } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for BinaryOp { }
    impl TryFrom<Token> for BinaryOp {
        type Error = Diagnostic;
        fn try_from(t: Token) -> Result<Self, Self::Error> {
            match t.kind {
                TokenKind::Operator(Operator::Plus) => Ok(Self::Plus),
                TokenKind::Operator(Operator::Minus) => Ok(Self::Minus),
                TokenKind::Operator(Operator::Star) => Ok(Self::Multiply),
                TokenKind::Operator(Operator::Slash) => Ok(Self::Divide),
                _ =>
                Err(Diagnostic{kind:
                                   ErrKind::Internal({
                                                         let res =
                                                             ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(&["Interner Fehler: Invalide Umwandlung von ",
                                                                                                                             " zu BinaryOp"],
                                                                                                                           &match (&t,)
                                                                                                                                {
                                                                                                                                (arg0,)
                                                                                                                                =>
                                                                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                              ::core::fmt::Debug::fmt)],
                                                                                                                            },
                                                                                                                           &[::core::fmt::rt::v1::Argument{position:
                                                                                                                                                               0usize,
                                                                                                                                                           format:
                                                                                                                                                               ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                   ' ',
                                                                                                                                                                                               align:
                                                                                                                                                                                                   ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                               flags:
                                                                                                                                                                                                   4u32,
                                                                                                                                                                                               precision:
                                                                                                                                                                                                   ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                               width:
                                                                                                                                                                                                   ::core::fmt::rt::v1::Count::Implied,},}]));
                                                         res
                                                     }),
                               suggestions: Vec::new(),
                               span: t.span,}),
            }
        }
    }
    pub enum CmpOp { EqEq, NotEq, Greater, GreaterEq, Less, LessEq, And, Or, }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for CmpOp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&CmpOp::EqEq,) => {
                    let mut debug_trait_builder = f.debug_tuple("EqEq");
                    debug_trait_builder.finish()
                }
                (&CmpOp::NotEq,) => {
                    let mut debug_trait_builder = f.debug_tuple("NotEq");
                    debug_trait_builder.finish()
                }
                (&CmpOp::Greater,) => {
                    let mut debug_trait_builder = f.debug_tuple("Greater");
                    debug_trait_builder.finish()
                }
                (&CmpOp::GreaterEq,) => {
                    let mut debug_trait_builder = f.debug_tuple("GreaterEq");
                    debug_trait_builder.finish()
                }
                (&CmpOp::Less,) => {
                    let mut debug_trait_builder = f.debug_tuple("Less");
                    debug_trait_builder.finish()
                }
                (&CmpOp::LessEq,) => {
                    let mut debug_trait_builder = f.debug_tuple("LessEq");
                    debug_trait_builder.finish()
                }
                (&CmpOp::And,) => {
                    let mut debug_trait_builder = f.debug_tuple("And");
                    debug_trait_builder.finish()
                }
                (&CmpOp::Or,) => {
                    let mut debug_trait_builder = f.debug_tuple("Or");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CmpOp { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CmpOp {
        #[inline]
        fn eq(&self, other: &CmpOp) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CmpOp {
        #[inline]
        fn clone(&self) -> CmpOp { { *self } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for CmpOp { }
    impl TryFrom<Token> for CmpOp {
        type Error = Diagnostic;
        fn try_from(t: Token) -> Result<Self, Self::Error> {
            match t.kind {
                TokenKind::Operator(Operator::EqEq) => Ok(CmpOp::EqEq),
                TokenKind::Operator(Operator::NotEq) => Ok(CmpOp::NotEq),
                TokenKind::Operator(Operator::Greater) => Ok(CmpOp::Greater),
                TokenKind::Operator(Operator::GreaterEq) =>
                Ok(CmpOp::GreaterEq),
                TokenKind::Operator(Operator::Less) => Ok(CmpOp::Less),
                TokenKind::Operator(Operator::LessEq) => Ok(CmpOp::LessEq),
                TokenKind::Operator(Operator::And) => Ok(CmpOp::And),
                TokenKind::Operator(Operator::Or) => Ok(CmpOp::Or),
                _ =>
                Err(Diagnostic{kind:
                                   ErrKind::Internal({
                                                         let res =
                                                             ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(&["Interner Fehler: Invalide Umwandlung von `",
                                                                                                                             "` zu CmpOp"],
                                                                                                                           &match (&t,)
                                                                                                                                {
                                                                                                                                (arg0,)
                                                                                                                                =>
                                                                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                              ::core::fmt::Debug::fmt)],
                                                                                                                            },
                                                                                                                           &[::core::fmt::rt::v1::Argument{position:
                                                                                                                                                               0usize,
                                                                                                                                                           format:
                                                                                                                                                               ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                   ' ',
                                                                                                                                                                                               align:
                                                                                                                                                                                                   ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                               flags:
                                                                                                                                                                                                   4u32,
                                                                                                                                                                                               precision:
                                                                                                                                                                                                   ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                               width:
                                                                                                                                                                                                   ::core::fmt::rt::v1::Count::Implied,},}]));
                                                         res
                                                     }),
                               suggestions: Vec::new(),
                               span: t.span,}),
            }
        }
    }
    pub enum UnaryOp { Minus, Not, }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnaryOp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&UnaryOp::Minus,) => {
                    let mut debug_trait_builder = f.debug_tuple("Minus");
                    debug_trait_builder.finish()
                }
                (&UnaryOp::Not,) => {
                    let mut debug_trait_builder = f.debug_tuple("Not");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for UnaryOp { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnaryOp {
        #[inline]
        fn eq(&self, other: &UnaryOp) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnaryOp {
        #[inline]
        fn clone(&self) -> UnaryOp { { *self } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for UnaryOp { }
    impl TryFrom<Token> for UnaryOp {
        type Error = Diagnostic;
        fn try_from(t: Token) -> Result<Self, Self::Error> {
            match t.kind {
                TokenKind::Operator(Operator::Not) => Ok(UnaryOp::Not),
                TokenKind::Operator(Operator::Minus) => Ok(UnaryOp::Minus),
                _ =>
                Err(Diagnostic{kind:
                                   ErrKind::Internal({
                                                         let res =
                                                             ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(&["Interner Fehler: Invalide Umwandlung von ",
                                                                                                                             " zu UnaryOp"],
                                                                                                                           &match (&t,)
                                                                                                                                {
                                                                                                                                (arg0,)
                                                                                                                                =>
                                                                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                              ::core::fmt::Debug::fmt)],
                                                                                                                            },
                                                                                                                           &[::core::fmt::rt::v1::Argument{position:
                                                                                                                                                               0usize,
                                                                                                                                                           format:
                                                                                                                                                               ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                   ' ',
                                                                                                                                                                                               align:
                                                                                                                                                                                                   ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                               flags:
                                                                                                                                                                                                   4u32,
                                                                                                                                                                                               precision:
                                                                                                                                                                                                   ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                               width:
                                                                                                                                                                                                   ::core::fmt::rt::v1::Count::Implied,},}]));
                                                         res
                                                     }),
                               suggestions: Vec::new(),
                               span: t.span,}),
            }
        }
    }
    pub struct Call {
        pub callee: Box<Expr>,
        pub args: Vec<Expr>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Call {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Call { callee: ref __self_0_0, args: ref __self_0_1 } => {
                    let mut debug_trait_builder = f.debug_struct("Call");
                    let _ =
                        debug_trait_builder.field("callee", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("args", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Call { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Call {
        #[inline]
        fn eq(&self, other: &Call) -> bool {
            match *other {
                Call { callee: ref __self_1_0, args: ref __self_1_1 } =>
                match *self {
                    Call { callee: ref __self_0_0, args: ref __self_0_1 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Call) -> bool {
            match *other {
                Call { callee: ref __self_1_0, args: ref __self_1_1 } =>
                match *self {
                    Call { callee: ref __self_0_0, args: ref __self_0_1 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    pub struct Span {
        pub lo: usize,
        pub hi: usize,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Span { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Span {
        #[inline]
        fn clone(&self) -> Span {
            {
                let _: ::core::clone::AssertParamIsClone<usize>;
                let _: ::core::clone::AssertParamIsClone<usize>;
                *self
            }
        }
    }
    impl PartialEq for Span {
        fn eq(&self, _: &Self) -> bool { true }
    }
    impl fmt::Display for Span {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&["", ".."],
                                                       &match (&self.lo,
                                                               &self.hi) {
                                                            (arg0, arg1) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt),
                                                             ::core::fmt::ArgumentV1::new(arg1,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    impl fmt::Debug for Span {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                       &match (&self,) {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    impl Default for Span {
        fn default() -> Self { Self{lo: 0, hi: 0,} }
    }
    impl Span {
        pub fn new(lo: usize, hi: usize) -> Self { Span{lo, hi,} }
        pub fn combine(&self, rhs: &Span) -> Self {
            Span{lo: std::cmp::min(self.lo, rhs.lo),
                 hi: std::cmp::max(self.hi, rhs.hi),}
        }
    }
}
mod cxt {
    use std::cmp::Eq;
    use std::collections::HashMap;
    use std::hash::Hash;
    pub struct Cxt<K: Eq + Hash + Clone, V: Clone> {
        global: HashMap<K, V>,
        stack: Vec<HashMap<K, V>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <K: ::core::fmt::Debug + Eq + Hash + Clone, V: ::core::fmt::Debug +
          Clone> ::core::fmt::Debug for Cxt<K, V> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Cxt { global: ref __self_0_0, stack: ref __self_0_1 } => {
                    let mut debug_trait_builder = f.debug_struct("Cxt");
                    let _ =
                        debug_trait_builder.field("global", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("stack", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl <K: Eq + Hash + Clone, V: Clone> Cxt<K, V> {
        pub fn new() -> Self {
            Self{global: HashMap::new(), stack: Vec::new(),}
        }
        pub fn make(&mut self) {
            let env: HashMap<K, V> =
                match self.stack.last() {
                    Some(env) => env.clone(),
                    None => HashMap::new(),
                };
            self.stack.push(env)
        }
        pub fn make_clean(&mut self) { self.stack.push(HashMap::new()); }
        pub fn drop(&mut self) { self.stack.pop(); }
        pub fn insert(&mut self, key: K, val: V) {
            match self.stack.last_mut() {
                Some(c) => { c.insert(key, val); }
                None => { self.make(); self.insert(key, val); }
            };
        }
        pub fn insert_global(&mut self, k: K, v: V) {
            self.global.insert(k, v);
        }
        pub fn get<'a>(&'a self, k: &'a K) -> Option<V> {
            let val = self.stack.last().unwrap().get(&k);
            match val {
                Some(_) => val.cloned(),
                None => self.global.get(&k).cloned(),
            }
        }
        pub fn get_mut<'a>(&'a mut self, k: &'a K) -> Option<&'a mut V> {
            for frame in self.stack.iter_mut().rev() {
                if frame.contains_key(k) { return frame.get_mut(k); }
            }
            None
        }
    }
}
mod errors {
    use std::fmt;
    use crate::ast::Span;
    use crate::lexer::TokenKind;
    use crate::session::SourceMap;
    use crate::typer::Ty;
    use crate::typer::TyKind;
    use colored::*;
    pub enum ErrKind {
        Syntax(SyntaxErr),
        Type(TypeErr),
        Runtime(RuntimeError),
        Warning {
            desc: String,
            msg: String,
        },
        Internal(String),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ErrKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&ErrKind::Syntax(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Syntax");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&ErrKind::Type(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Type");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&ErrKind::Runtime(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Runtime");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&ErrKind::Warning { desc: ref __self_0, msg: ref __self_1 },)
                => {
                    let mut debug_trait_builder = f.debug_struct("Warning");
                    let _ = debug_trait_builder.field("desc", &&(*__self_0));
                    let _ = debug_trait_builder.field("msg", &&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&ErrKind::Internal(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Internal");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ErrKind {
        #[inline]
        fn clone(&self) -> ErrKind {
            match (&*self,) {
                (&ErrKind::Syntax(ref __self_0),) =>
                ErrKind::Syntax(::core::clone::Clone::clone(&(*__self_0))),
                (&ErrKind::Type(ref __self_0),) =>
                ErrKind::Type(::core::clone::Clone::clone(&(*__self_0))),
                (&ErrKind::Runtime(ref __self_0),) =>
                ErrKind::Runtime(::core::clone::Clone::clone(&(*__self_0))),
                (&ErrKind::Warning { desc: ref __self_0, msg: ref __self_1 },)
                =>
                ErrKind::Warning{desc:
                                     ::core::clone::Clone::clone(&(*__self_0)),
                                 msg:
                                     ::core::clone::Clone::clone(&(*__self_1)),},
                (&ErrKind::Internal(ref __self_0),) =>
                ErrKind::Internal(::core::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    impl fmt::Display for ErrKind {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                ErrKind::Syntax(s_err) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&s_err,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                ErrKind::Type(t_err) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&t_err,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                ErrKind::Runtime(r_err) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&r_err,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                ErrKind::Warning { desc, msg } =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", " \n"],
                                                           &match (&desc,
                                                                   &msg) {
                                                                (arg0, arg1)
                                                                =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                ErrKind::Internal(i_err) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&i_err,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
            }
        }
    }
    pub enum SyntaxErr {
        UnexpectedChar(char),
        UnterminatedString,
        SelfOutsideImpl,
        MissingToken {
            expected: Vec<TokenKind>,
            actual: TokenKind,
        },
        ExpectedTy,
        ExpectedExpr,
        InvalidAssignmentTarget,
        InvalidVarDefTarget,
        UnbalancedParen,
        BreakOutsideLoop,
        UnexpectedEOF,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for SyntaxErr {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&SyntaxErr::UnexpectedChar(ref __self_0),) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("UnexpectedChar");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::UnterminatedString,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("UnterminatedString");
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::SelfOutsideImpl,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("SelfOutsideImpl");
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::MissingToken {
                 expected: ref __self_0, actual: ref __self_1 },) => {
                    let mut debug_trait_builder =
                        f.debug_struct("MissingToken");
                    let _ =
                        debug_trait_builder.field("expected", &&(*__self_0));
                    let _ =
                        debug_trait_builder.field("actual", &&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::ExpectedTy,) => {
                    let mut debug_trait_builder = f.debug_tuple("ExpectedTy");
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::ExpectedExpr,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("ExpectedExpr");
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::InvalidAssignmentTarget,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("InvalidAssignmentTarget");
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::InvalidVarDefTarget,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("InvalidVarDefTarget");
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::UnbalancedParen,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("UnbalancedParen");
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::BreakOutsideLoop,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("BreakOutsideLoop");
                    debug_trait_builder.finish()
                }
                (&SyntaxErr::UnexpectedEOF,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("UnexpectedEOF");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SyntaxErr {
        #[inline]
        fn clone(&self) -> SyntaxErr {
            match (&*self,) {
                (&SyntaxErr::UnexpectedChar(ref __self_0),) =>
                SyntaxErr::UnexpectedChar(::core::clone::Clone::clone(&(*__self_0))),
                (&SyntaxErr::UnterminatedString,) =>
                SyntaxErr::UnterminatedString,
                (&SyntaxErr::SelfOutsideImpl,) => SyntaxErr::SelfOutsideImpl,
                (&SyntaxErr::MissingToken {
                 expected: ref __self_0, actual: ref __self_1 },) =>
                SyntaxErr::MissingToken{expected:
                                            ::core::clone::Clone::clone(&(*__self_0)),
                                        actual:
                                            ::core::clone::Clone::clone(&(*__self_1)),},
                (&SyntaxErr::ExpectedTy,) => SyntaxErr::ExpectedTy,
                (&SyntaxErr::ExpectedExpr,) => SyntaxErr::ExpectedExpr,
                (&SyntaxErr::InvalidAssignmentTarget,) =>
                SyntaxErr::InvalidAssignmentTarget,
                (&SyntaxErr::InvalidVarDefTarget,) =>
                SyntaxErr::InvalidVarDefTarget,
                (&SyntaxErr::UnbalancedParen,) => SyntaxErr::UnbalancedParen,
                (&SyntaxErr::BreakOutsideLoop,) =>
                SyntaxErr::BreakOutsideLoop,
                (&SyntaxErr::UnexpectedEOF,) => SyntaxErr::UnexpectedEOF,
            }
        }
    }
    impl fmt::Display for SyntaxErr {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                SyntaxErr::UnexpectedChar(c) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Wir denken das Zeichen : \u{b4}",
                                                             "\u{b4} geh\u{f6}rt dort nicht hin."],
                                                           &match (&c,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                SyntaxErr::UnterminatedString =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Wir denken du hast vergessen einen Text zu schlie\u{df}en."],
                                                           &match () {
                                                                () => [],
                                                            })),
                SyntaxErr::SelfOutsideImpl =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Du hast vergessen die Methode in einen Implementierungsblock zu schreiben. Versuche die Funktion in einen Implementierungsblock zu schreiben."],
                                                           &match () {
                                                                () => [],
                                                            })),
                SyntaxErr::MissingToken { expected, actual } =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Wir haben hier eher \u{b4}",
                                                             "\u{b4} erwartet, als ",
                                                             ". Versuche doch ",
                                                             " durch ",
                                                             " zu ersetzen."],
                                                           &match (&expected,
                                                                   &actual,
                                                                   &expected,
                                                                   &actual) {
                                                                (arg0, arg1,
                                                                 arg2, arg3)
                                                                =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Debug::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg2,
                                                                                              ::core::fmt::Debug::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg3,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                SyntaxErr::ExpectedTy =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["An dieser Stelle haben wir einen Datentypen erwartet!"],
                                                           &match () {
                                                                () => [],
                                                            })),
                SyntaxErr::ExpectedExpr =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["An dieser Stelle haben wir einen mathematischen Ausdurck erwartet!"],
                                                           &match () {
                                                                () => [],
                                                            })),
                SyntaxErr::InvalidAssignmentTarget =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Der folgende Ausdruck ist nicht als Zuweisungsziel erlaubt."],
                                                           &match () {
                                                                () => [],
                                                            })),
                SyntaxErr::InvalidVarDefTarget =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Wir denken du hast hier ein falsches Zuweisungsziel ausgew\u{e4}hlt. Der Zuweisungsoperator \u{b4}:=\u{b4} erlaubt dir Variablen zu definieren um in diesen einen Wert zu speichern."],
                                                           &match () {
                                                                () => [],
                                                            })),
                SyntaxErr::UnbalancedParen =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Schau bitte ob du irgendwo Klammern vergessen oder zu viel gesetzt hast. Wir aben hier eine Ungleicheit zwischen offenen und geschlossenen Klammern festgestellt."],
                                                           &match () {
                                                                () => [],
                                                            })),
                SyntaxErr::BreakOutsideLoop =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Wir denken wir haben ein `break` aushalb einer schleife entdeckt. Schau bitte, dass break nur in einer Schleife vorkommt."],
                                                           &match () {
                                                                () => [],
                                                            })),
                SyntaxErr::UnexpectedEOF =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Wir haben unerwartet das Ende der Datei erreicht! Schau bitte, dass du dein Code vollst\u{e4}ndig schreibst und richtig abschlie\u{df}t!"],
                                                           &match () {
                                                                () => [],
                                                            })),
            }
        }
    }
    pub enum TypeErr {
        VarNotFound(String),
        TyNotFound(String),
        InvalidType,
        InfRec(TyKind, TyKind),
        DuplicateLitField(String),
        MissingField(String),
        InvalidField(String, String),
        FieldNotFound {
            ty: Ty,
            field: String,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeErr {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TypeErr::VarNotFound(ref __self_0),) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("VarNotFound");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TypeErr::TyNotFound(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("TyNotFound");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TypeErr::InvalidType,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("InvalidType");
                    debug_trait_builder.finish()
                }
                (&TypeErr::InfRec(ref __self_0, ref __self_1),) => {
                    let mut debug_trait_builder = f.debug_tuple("InfRec");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    let _ = debug_trait_builder.field(&&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&TypeErr::DuplicateLitField(ref __self_0),) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("DuplicateLitField");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TypeErr::MissingField(ref __self_0),) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("MissingField");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TypeErr::InvalidField(ref __self_0, ref __self_1),) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("InvalidField");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    let _ = debug_trait_builder.field(&&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&TypeErr::FieldNotFound {
                 ty: ref __self_0, field: ref __self_1 },) => {
                    let mut debug_trait_builder =
                        f.debug_struct("FieldNotFound");
                    let _ = debug_trait_builder.field("ty", &&(*__self_0));
                    let _ = debug_trait_builder.field("field", &&(*__self_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeErr {
        #[inline]
        fn clone(&self) -> TypeErr {
            match (&*self,) {
                (&TypeErr::VarNotFound(ref __self_0),) =>
                TypeErr::VarNotFound(::core::clone::Clone::clone(&(*__self_0))),
                (&TypeErr::TyNotFound(ref __self_0),) =>
                TypeErr::TyNotFound(::core::clone::Clone::clone(&(*__self_0))),
                (&TypeErr::InvalidType,) => TypeErr::InvalidType,
                (&TypeErr::InfRec(ref __self_0, ref __self_1),) =>
                TypeErr::InfRec(::core::clone::Clone::clone(&(*__self_0)),
                                ::core::clone::Clone::clone(&(*__self_1))),
                (&TypeErr::DuplicateLitField(ref __self_0),) =>
                TypeErr::DuplicateLitField(::core::clone::Clone::clone(&(*__self_0))),
                (&TypeErr::MissingField(ref __self_0),) =>
                TypeErr::MissingField(::core::clone::Clone::clone(&(*__self_0))),
                (&TypeErr::InvalidField(ref __self_0, ref __self_1),) =>
                TypeErr::InvalidField(::core::clone::Clone::clone(&(*__self_0)),
                                      ::core::clone::Clone::clone(&(*__self_1))),
                (&TypeErr::FieldNotFound {
                 ty: ref __self_0, field: ref __self_1 },) =>
                TypeErr::FieldNotFound{ty:
                                           ::core::clone::Clone::clone(&(*__self_0)),
                                       field:
                                           ::core::clone::Clone::clone(&(*__self_1)),},
            }
        }
    }
    impl fmt::Display for TypeErr {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                TypeErr::VarNotFound(varname) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Diese Variable `",
                                                             "` haben wir nicht gefunden. Bitte Definiere und Initialisiere sie, bevor du sie benutzt."],
                                                           &match (&varname,)
                                                                {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                TypeErr::InvalidType =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Du hast hier einen Typ benutzt der entweder gar nicht existiert oder hier nicht funktioniert. Bitte schau da nochmal dr\u{fc}ber."],
                                                           &match () {
                                                                () => [],
                                                            })),
                TypeErr::InfRec(a, b) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Unendlich rekursiver Typ entdeckt! Typ: ",
                                                             ", kommt in ",
                                                             " vor!!!"],
                                                           &match (&a, &b) {
                                                                (arg0, arg1)
                                                                =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                TypeErr::FieldNotFound { ty, field } =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Der Datentyp ",
                                                             " hat kein Feld mit dem Namen ",
                                                             "!"],
                                                           &match (&ty,
                                                                   &field) {
                                                                (arg0, arg1)
                                                                =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                TypeErr::TyNotFound(t) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Keine Defintion fuer den Datentyp ",
                                                             " gefunden"],
                                                           &match (&t,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                TypeErr::DuplicateLitField(field) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Jedes Feld eines Objektes kann nur einmal vorkommen, \'",
                                                             "\' kommt dabei allerdings mehr als einmal vor!"],
                                                           &match (&field,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                TypeErr::MissingField(field) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Du hast vergessen dem Feld ",
                                                             " einen Wert zu geben!"],
                                                           &match (&field,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                TypeErr::InvalidField(ty, field) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Der Datentyp: ",
                                                             " hat kein Feld mit dem Namen: ",
                                                             "!"],
                                                           &match (&ty,
                                                                   &field) {
                                                                (arg0, arg1)
                                                                =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
            }
        }
    }
    pub enum RuntimeError {
        OutOfBounds {
            index: isize,
            len: usize,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for RuntimeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&RuntimeError::OutOfBounds {
                 index: ref __self_0, len: ref __self_1 },) => {
                    let mut debug_trait_builder =
                        f.debug_struct("OutOfBounds");
                    let _ = debug_trait_builder.field("index", &&(*__self_0));
                    let _ = debug_trait_builder.field("len", &&(*__self_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for RuntimeError {
        #[inline]
        fn clone(&self) -> RuntimeError {
            match (&*self,) {
                (&RuntimeError::OutOfBounds {
                 index: ref __self_0, len: ref __self_1 },) =>
                RuntimeError::OutOfBounds{index:
                                              ::core::clone::Clone::clone(&(*__self_0)),
                                          len:
                                              ::core::clone::Clone::clone(&(*__self_1)),},
            }
        }
    }
    impl fmt::Display for RuntimeError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                RuntimeError::OutOfBounds { index, len } =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["Du hast versucht auf einen Index au\u{df}erhalb des Feldes zuzugreifen, die L\u{e4}nge des Feldes betr\u{e4}gt ",
                                                             ". Du hast versucht auf die Postition ",
                                                             " zuzugreifen!"],
                                                           &match (&len,
                                                                   &index) {
                                                                (arg0, arg1)
                                                                =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
            }
        }
    }
    pub struct Diagnostic {
        pub kind: ErrKind,
        pub suggestions: Vec<String>,
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Diagnostic {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Diagnostic {
                kind: ref __self_0_0,
                suggestions: ref __self_0_1,
                span: ref __self_0_2 } => {
                    let mut debug_trait_builder =
                        f.debug_struct("Diagnostic");
                    let _ =
                        debug_trait_builder.field("kind", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("suggestions",
                                                  &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("span", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Diagnostic {
        #[inline]
        fn clone(&self) -> Diagnostic {
            match *self {
                Diagnostic {
                kind: ref __self_0_0,
                suggestions: ref __self_0_1,
                span: ref __self_0_2 } =>
                Diagnostic{kind: ::core::clone::Clone::clone(&(*__self_0_0)),
                           suggestions:
                               ::core::clone::Clone::clone(&(*__self_0_1)),
                           span:
                               ::core::clone::Clone::clone(&(*__self_0_2)),},
            }
        }
    }
    impl Diagnostic {
        pub fn new(kind: ErrKind, suggestions: Vec<String>, span: Span)
         -> Self {
            Self{kind,
                 suggestions:
                     suggestions.into_iter().map(|s|
                                                     s.into()).collect::<Vec<String>>(),
                 span,}
        }
        pub fn suggest<S: Into<String>>(self, sug: S) -> Self {
            let mut diag = self;
            diag.suggestions.push(sug.into());
            diag
        }
        #[allow(dead_code)]
        pub fn add_suggestion<S: Into<String>>(&mut self, sug: S) {
            self.suggestions.push(sug.into());
        }
    }
    pub struct UserDiagnostic {
        pub src_map: SourceMap,
        pub kind: ErrKind,
        pub suggestions: Vec<String>,
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UserDiagnostic {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UserDiagnostic {
                src_map: ref __self_0_0,
                kind: ref __self_0_1,
                suggestions: ref __self_0_2,
                span: ref __self_0_3 } => {
                    let mut debug_trait_builder =
                        f.debug_struct("UserDiagnostic");
                    let _ =
                        debug_trait_builder.field("src_map", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("kind", &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("suggestions",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("span", &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl UserDiagnostic {
        pub fn new(diag: Diagnostic, src_map: SourceMap) -> Self {
            Self{src_map,
                 kind: diag.kind,
                 suggestions: diag.suggestions,
                 span: diag.span,}
        }
        fn underline(&self) -> String {
            let buf_len = self.span.hi - self.span.lo;
            (0..=buf_len).map(|_| "^").collect::<String>()
        }
        fn span_snippet(&self) -> String {
            let s = self.line_span();
            let buf = &self.src_map.buf;
            buf[s.lo..s.hi].trim_start().to_string()
        }
        fn line_span(&self) -> Span {
            let mut line_offsets = <[_]>::into_vec(box [0]);
            line_offsets.extend(self.src_map.buf.char_indices().filter(|(_,
                                                                         c)|
                                                                           *c
                                                                               ==
                                                                               '\n').map(|(i,
                                                                                           _)|
                                                                                             i).collect::<Vec<usize>>());
            let mut it = line_offsets.into_iter().peekable();
            let mut lo = 0;
            while let Some(offset) = it.next() {
                if offset == self.span.lo ||
                       *it.peek().unwrap() >= self.span.lo {
                    lo = offset;
                    break ;
                }
            }
            let hi = it.next().unwrap();
            let (lo, _) =
                self.src_map.buf.char_indices().skip(lo).find(|(_, c)|
                                                                  !c.is_whitespace()).unwrap();
            Span::new(lo, hi)
        }
        fn line_num(&self) -> usize {
            self.src_map.buf.char_indices().filter(|(_, c)|
                                                       *c ==
                                                           '\n').position(|(i,
                                                                            _)|
                                                                              i
                                                                                  >=
                                                                                  self.span.lo).expect("failed to compute line number of err")
                + 1
        }
        fn write_code_snippet(&self, f: &mut fmt::Formatter, c: Color)
         -> fmt::Result {
            let line_str =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[" ",
                                                                              " |"],
                                                                            &match (&self.line_num(),)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                };
            let align = line_str.len();
            let u_line = self.underline();
            f.write_fmt(::core::fmt::Arguments::new_v1_formatted(&["", "\n"],
                                                                 &match (&"|",
                                                                         &align)
                                                                      {
                                                                      (arg0,
                                                                       arg1)
                                                                      =>
                                                                      [::core::fmt::ArgumentV1::new(arg0,
                                                                                                    ::core::fmt::Display::fmt),
                                                                       ::core::fmt::ArgumentV1::from_usize(arg1)],
                                                                  },
                                                                 &[::core::fmt::rt::v1::Argument{position:
                                                                                                     0usize,
                                                                                                 format:
                                                                                                     ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                         ' ',
                                                                                                                                     align:
                                                                                                                                         ::core::fmt::rt::v1::Alignment::Right,
                                                                                                                                     flags:
                                                                                                                                         0u32,
                                                                                                                                     precision:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                     width:
                                                                                                                                         ::core::fmt::rt::v1::Count::Param(1usize),},}]))?;
            f.write_fmt(::core::fmt::Arguments::new_v1(&["", " ", "\n"],
                                                       &match (&line_str,
                                                               &self.span_snippet())
                                                            {
                                                            (arg0, arg1) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt),
                                                             ::core::fmt::ArgumentV1::new(arg1,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))?;
            f.write_fmt(::core::fmt::Arguments::new_v1_formatted(&["", " ",
                                                                   "\n"],
                                                                 &match (&"|",
                                                                         &u_line.color(c).bold(),
                                                                         &align,
                                                                         &(self.span.lo
                                                                               -
                                                                               self.line_span().lo
                                                                               +
                                                                               u_line.len()))
                                                                      {
                                                                      (arg0,
                                                                       arg1,
                                                                       arg2,
                                                                       arg3)
                                                                      =>
                                                                      [::core::fmt::ArgumentV1::new(arg0,
                                                                                                    ::core::fmt::Display::fmt),
                                                                       ::core::fmt::ArgumentV1::new(arg1,
                                                                                                    ::core::fmt::Display::fmt),
                                                                       ::core::fmt::ArgumentV1::from_usize(arg2),
                                                                       ::core::fmt::ArgumentV1::from_usize(arg3)],
                                                                  },
                                                                 &[::core::fmt::rt::v1::Argument{position:
                                                                                                     0usize,
                                                                                                 format:
                                                                                                     ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                         ' ',
                                                                                                                                     align:
                                                                                                                                         ::core::fmt::rt::v1::Alignment::Right,
                                                                                                                                     flags:
                                                                                                                                         0u32,
                                                                                                                                     precision:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                     width:
                                                                                                                                         ::core::fmt::rt::v1::Count::Param(2usize),},},
                                                                   ::core::fmt::rt::v1::Argument{position:
                                                                                                     1usize,
                                                                                                 format:
                                                                                                     ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                         ' ',
                                                                                                                                     align:
                                                                                                                                         ::core::fmt::rt::v1::Alignment::Right,
                                                                                                                                     flags:
                                                                                                                                         0u32,
                                                                                                                                     precision:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                     width:
                                                                                                                                         ::core::fmt::rt::v1::Count::Param(3usize),},}]))?;
            f.write_fmt(::core::fmt::Arguments::new_v1_formatted(&["", " ",
                                                                   ": ",
                                                                   "\n"],
                                                                 &match (&"|",
                                                                         &"Hilfe".bold().underline(),
                                                                         &self.kind,
                                                                         &align)
                                                                      {
                                                                      (arg0,
                                                                       arg1,
                                                                       arg2,
                                                                       arg3)
                                                                      =>
                                                                      [::core::fmt::ArgumentV1::new(arg0,
                                                                                                    ::core::fmt::Display::fmt),
                                                                       ::core::fmt::ArgumentV1::new(arg1,
                                                                                                    ::core::fmt::Display::fmt),
                                                                       ::core::fmt::ArgumentV1::new(arg2,
                                                                                                    ::core::fmt::Display::fmt),
                                                                       ::core::fmt::ArgumentV1::from_usize(arg3)],
                                                                  },
                                                                 &[::core::fmt::rt::v1::Argument{position:
                                                                                                     0usize,
                                                                                                 format:
                                                                                                     ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                         ' ',
                                                                                                                                     align:
                                                                                                                                         ::core::fmt::rt::v1::Alignment::Right,
                                                                                                                                     flags:
                                                                                                                                         0u32,
                                                                                                                                     precision:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                     width:
                                                                                                                                         ::core::fmt::rt::v1::Count::Param(3usize),},},
                                                                   ::core::fmt::rt::v1::Argument{position:
                                                                                                     1usize,
                                                                                                 format:
                                                                                                     ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                         ' ',
                                                                                                                                     align:
                                                                                                                                         ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                     flags:
                                                                                                                                         0u32,
                                                                                                                                     precision:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                     width:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,},},
                                                                   ::core::fmt::rt::v1::Argument{position:
                                                                                                     2usize,
                                                                                                 format:
                                                                                                     ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                         ' ',
                                                                                                                                     align:
                                                                                                                                         ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                     flags:
                                                                                                                                         0u32,
                                                                                                                                     precision:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                     width:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,},}]))
        }
    }
    impl fmt::Display for UserDiagnostic {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let color =
                match self.kind {
                    ErrKind::Warning { .. } => Color::Yellow,
                    ErrKind::Internal(_) => Color::BrightMagenta,
                    _ => Color::Red,
                };
            let msg =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&self.kind,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                }.color(color).bold();
            f.write_fmt(::core::fmt::Arguments::new_v1(&["", " ", " ", "[",
                                                         "]\n"],
                                                       &match (&"--".bold(),
                                                               &msg,
                                                               &"------------------------------------------".bold(),
                                                               &self.src_map.path.to_str().unwrap().blue())
                                                            {
                                                            (arg0, arg1, arg2,
                                                             arg3) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt),
                                                             ::core::fmt::ArgumentV1::new(arg1,
                                                                                          ::core::fmt::Display::fmt),
                                                             ::core::fmt::ArgumentV1::new(arg2,
                                                                                          ::core::fmt::Display::fmt),
                                                             ::core::fmt::ArgumentV1::new(arg3,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))?;
            f.write_fmt(::core::fmt::Arguments::new_v1(&["\n"],
                                                       &match () {
                                                            () => [],
                                                        }))?;
            self.write_code_snippet(f, color)?;
            f.write_fmt(::core::fmt::Arguments::new_v1(&["\n"],
                                                       &match () {
                                                            () => [],
                                                        }))?;
            for sug in &self.suggestions {
                f.write_fmt(::core::fmt::Arguments::new_v1(&[" \u{2022} ",
                                                             "\n"],
                                                           &match (&sug,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            }))?;
            }
            f.write_fmt(::core::fmt::Arguments::new_v1(&[],
                                                       &match () {
                                                            () => [],
                                                        }))
        }
    }
}
mod formatter {
    use crate::ast::*;
    use crate::lexer::Lit;
    use crate::typer::{Ty, TyKind};
    use std::fmt;
    impl fmt::Display for Stmt {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Stmt::Assign { lhs, rhs, span: _ } =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", " = ", "\n"],
                                                           &match (&lhs, &rhs)
                                                                {
                                                                (arg0, arg1)
                                                                =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                Stmt::Block(b) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", "\n"],
                                                           &match (&b,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                Stmt::Break(_) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["stop;\n"],
                                                           &match () {
                                                                () => [],
                                                            })),
                Stmt::Continue(_) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["weiter;\n"],
                                                           &match () {
                                                                () => [],
                                                            })),
                Stmt::Expr(e) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", ";\n"],
                                                           &match (&e,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                Stmt::For { vardef, body, span: _ } => {
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["", "\n"],
                                                               &match (&vardef,)
                                                                    {
                                                                    (arg0,) =>
                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                  ::core::fmt::Display::fmt)],
                                                                }))?;
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["", "\n"],
                                                               &match (&body,)
                                                                    {
                                                                    (arg0,) =>
                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                  ::core::fmt::Display::fmt)],
                                                                }))
                }
                Stmt::While { cond, body, span: _ } => {
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["wenn ",
                                                                 " \n"],
                                                               &match (&cond,)
                                                                    {
                                                                    (arg0,) =>
                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                  ::core::fmt::Display::fmt)],
                                                                }))?;
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["", "\n"],
                                                               &match (&body,)
                                                                    {
                                                                    (arg0,) =>
                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                  ::core::fmt::Display::fmt)],
                                                                }))
                }
                Stmt::Ret(e, _) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", "\n"],
                                                           &match (&e,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                Stmt::VarDef(v) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", "\n"],
                                                           &match (&v,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                _ => { ::std::rt::begin_panic("not yet implemented") }
            }
        }
    }
    impl fmt::Display for Expr {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match &self.node {
                ExprKind::Binary { lhs, rhs, op } =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", " ", " "],
                                                           &match (&lhs, &op,
                                                                   &rhs) {
                                                                (arg0, arg1,
                                                                 arg2) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg2,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                ExprKind::Logical { lhs, rhs, op } =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", " ", " "],
                                                           &match (&lhs, &op,
                                                                   &rhs) {
                                                                (arg0, arg1,
                                                                 arg2) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg2,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                ExprKind::Unary { op, rhs } =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                           &match (&op, &rhs)
                                                                {
                                                                (arg0, arg1)
                                                                =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                ExprKind::Lit(l) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&l,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                e =>
                f.write_fmt(::core::fmt::Arguments::new_v1_formatted(&[""],
                                                                     &match (&e,)
                                                                          {
                                                                          (arg0,)
                                                                          =>
                                                                          [::core::fmt::ArgumentV1::new(arg0,
                                                                                                        ::core::fmt::Debug::fmt)],
                                                                      },
                                                                     &[::core::fmt::rt::v1::Argument{position:
                                                                                                         0usize,
                                                                                                     format:
                                                                                                         ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                             ' ',
                                                                                                                                         align:
                                                                                                                                             ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                         flags:
                                                                                                                                             4u32,
                                                                                                                                         precision:
                                                                                                                                             ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                         width:
                                                                                                                                             ::core::fmt::rt::v1::Count::Implied,},}])),
            }
        }
    }
    impl fmt::Display for BinaryOp {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                BinaryOp::Plus =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["+"],
                                                           &match () {
                                                                () => [],
                                                            })),
                BinaryOp::Minus =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["-"],
                                                           &match () {
                                                                () => [],
                                                            })),
                BinaryOp::Multiply =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["*"],
                                                           &match () {
                                                                () => [],
                                                            })),
                BinaryOp::Divide =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["/"],
                                                           &match () {
                                                                () => [],
                                                            })),
            }
        }
    }
    impl fmt::Display for CmpOp {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                CmpOp::EqEq =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["gleich"],
                                                           &match () {
                                                                () => [],
                                                            })),
                CmpOp::NotEq =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["ungleich"],
                                                           &match () {
                                                                () => [],
                                                            })),
                CmpOp::Greater =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[">"],
                                                           &match () {
                                                                () => [],
                                                            })),
                CmpOp::GreaterEq =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[">="],
                                                           &match () {
                                                                () => [],
                                                            })),
                CmpOp::Less =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[">"],
                                                           &match () {
                                                                () => [],
                                                            })),
                CmpOp::LessEq =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["<="],
                                                           &match () {
                                                                () => [],
                                                            })),
                CmpOp::And =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["und"],
                                                           &match () {
                                                                () => [],
                                                            })),
                CmpOp::Or =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["oder"],
                                                           &match () {
                                                                () => [],
                                                            })),
            }
        }
    }
    impl fmt::Display for UnaryOp {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                UnaryOp::Minus =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["-"],
                                                           &match () {
                                                                () => [],
                                                            })),
                UnaryOp::Not =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["nicht"],
                                                           &match () {
                                                                () => [],
                                                            })),
            }
        }
    }
    impl fmt::Display for Lit {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Lit::Number(n) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&n,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                Lit::Bool(v) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&v,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                Lit::String(s) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&s,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
            }
        }
    }
    impl fmt::Display for Block {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&["", "\n"],
                                                       &match (&self.stmts.iter().map(|s|
                                                                                          {
                                                                                              let res =
                                                                                                  ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                                                                                                      &match (&s,)
                                                                                                                                                           {
                                                                                                                                                           (arg0,)
                                                                                                                                                           =>
                                                                                                                                                           [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                         ::core::fmt::Display::fmt)],
                                                                                                                                                       }));
                                                                                              res
                                                                                          }).collect::<Vec<_>>().join("\n"),)
                                                            {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    impl fmt::Display for Ident {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&["", "\n"],
                                                       &match (&self.lexeme,)
                                                            {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    impl fmt::Display for Ty {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1_formatted(&["", "\n"],
                                                                 &match (&self.kind,)
                                                                      {
                                                                      (arg0,)
                                                                      =>
                                                                      [::core::fmt::ArgumentV1::new(arg0,
                                                                                                    ::core::fmt::Debug::fmt)],
                                                                  },
                                                                 &[::core::fmt::rt::v1::Argument{position:
                                                                                                     0usize,
                                                                                                 format:
                                                                                                     ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                         ' ',
                                                                                                                                     align:
                                                                                                                                         ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                     flags:
                                                                                                                                         4u32,
                                                                                                                                     precision:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                     width:
                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,},}]))
        }
    }
    impl fmt::Display for VarDef {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let ty =
                match self.ty.kind {
                    TyKind::Infer => String::new(),
                    _ => {
                        let res =
                            ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                                &match (&self.ty,)
                                                                                     {
                                                                                     (arg0,)
                                                                                     =>
                                                                                     [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                   ::core::fmt::Display::fmt)],
                                                                                 }));
                        res
                    }
                };
            f.write_fmt(::core::fmt::Arguments::new_v1(&["", " :", "= "],
                                                       &match (&self.pat, &ty,
                                                               &self.init) {
                                                            (arg0, arg1, arg2)
                                                            =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt),
                                                             ::core::fmt::ArgumentV1::new(arg1,
                                                                                          ::core::fmt::Display::fmt),
                                                             ::core::fmt::ArgumentV1::new(arg2,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    impl fmt::Display for Path {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let p =
                self.segments.iter().map(|s|
                                             s.lexeme.clone()).collect::<Vec<String>>().join("::");
            f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                       &match (&p,) {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
}
mod interp {
    use crate::ast::*;
    use std::convert::From;
    use std::fmt;
    use crate::errors::*;
    use crate::lexer::Lit;
    use std::collections::HashMap;
    use crate::ast::*;
    use crate::cxt::Cxt;
    macro_rules! cast(($ val : expr, $ p : path) =>
                      {
                          match $ val
                          {
                              $ p(x) => x, _ =>
                              {
                                  let pat = stringify ! ($ pat) ; let val =
                                  stringify ! ($ val) ; panic !
                                  ("Invalide Umwandlung, {:#?} entspricht nicht folgendem Muster: {:#?} dies ist wahrscheinlich ein Fehler im Typenchecker!",
                                   val, pat) ;
                              }
                          }
                      })
    pub enum Value {
        Num(f64),
        Text(String),
        Bool(bool),
        Object(Ident, HashMap<String, Value>),
        Tup(Vec<Value>),
        Array(Vec<Value>),
        Fn(FnDecl),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Value {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Value::Num(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Num");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::Text(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Text");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::Bool(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Bool");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::Object(ref __self_0, ref __self_1),) => {
                    let mut debug_trait_builder = f.debug_tuple("Object");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    let _ = debug_trait_builder.field(&&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&Value::Tup(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Tup");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::Array(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Array");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::Fn(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Fn");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Value {
        #[inline]
        fn clone(&self) -> Value {
            match (&*self,) {
                (&Value::Num(ref __self_0),) =>
                Value::Num(::core::clone::Clone::clone(&(*__self_0))),
                (&Value::Text(ref __self_0),) =>
                Value::Text(::core::clone::Clone::clone(&(*__self_0))),
                (&Value::Bool(ref __self_0),) =>
                Value::Bool(::core::clone::Clone::clone(&(*__self_0))),
                (&Value::Object(ref __self_0, ref __self_1),) =>
                Value::Object(::core::clone::Clone::clone(&(*__self_0)),
                              ::core::clone::Clone::clone(&(*__self_1))),
                (&Value::Tup(ref __self_0),) =>
                Value::Tup(::core::clone::Clone::clone(&(*__self_0))),
                (&Value::Array(ref __self_0),) =>
                Value::Array(::core::clone::Clone::clone(&(*__self_0))),
                (&Value::Fn(ref __self_0),) =>
                Value::Fn(::core::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Value { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Value {
        #[inline]
        fn eq(&self, other: &Value) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Value::Num(ref __self_0),
                         &Value::Num(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Value::Text(ref __self_0),
                         &Value::Text(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Value::Bool(ref __self_0),
                         &Value::Bool(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Value::Object(ref __self_0, ref __self_1),
                         &Value::Object(ref __arg_1_0, ref __arg_1_1)) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&Value::Tup(ref __self_0),
                         &Value::Tup(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Value::Array(ref __self_0),
                         &Value::Array(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Value::Fn(ref __self_0), &Value::Fn(ref __arg_1_0))
                        => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &Value) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Value::Num(ref __self_0),
                         &Value::Num(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Value::Text(ref __self_0),
                         &Value::Text(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Value::Bool(ref __self_0),
                         &Value::Bool(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Value::Object(ref __self_0, ref __self_1),
                         &Value::Object(ref __arg_1_0, ref __arg_1_1)) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&Value::Tup(ref __self_0),
                         &Value::Tup(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Value::Array(ref __self_0),
                         &Value::Array(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Value::Fn(ref __self_0), &Value::Fn(ref __arg_1_0))
                        => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    impl fmt::Display for Value {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Value::Num(n) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&n,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                Value::Text(t) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&t,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
                Value::Bool(b) => {
                    let str_bool =
                        match b { true => "wahr", false => "falsch", };
                    f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                               &match (&str_bool,)
                                                                    {
                                                                    (arg0,) =>
                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                  ::core::fmt::Display::fmt)],
                                                                }))
                }
                Value::Array(arr) => {
                    let values =
                        arr.iter().map(|v|
                                           {
                                               let res =
                                                   ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                                                       &match (&v,)
                                                                                                            {
                                                                                                            (arg0,)
                                                                                                            =>
                                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                                        }));
                                               res
                                           }).collect::<Vec<String>>().join(", ");
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["[", "]"],
                                                               &match (&values,)
                                                                    {
                                                                    (arg0,) =>
                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                  ::core::fmt::Display::fmt)],
                                                                }))
                }
                Value::Tup(tup) => {
                    let values =
                        tup.iter().map(|v|
                                           {
                                               let res =
                                                   ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                                                       &match (&v,)
                                                                                                            {
                                                                                                            (arg0,)
                                                                                                            =>
                                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                                        }));
                                               res
                                           }).collect::<Vec<String>>().join(", ");
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["(", ")"],
                                                               &match (&values,)
                                                                    {
                                                                    (arg0,) =>
                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                  ::core::fmt::Display::fmt)],
                                                                }))
                }
                Value::Object(path, obj) =>
                f.write_fmt(::core::fmt::Arguments::new_v1_formatted(&["",
                                                                       ": "],
                                                                     &match (&path,
                                                                             &obj)
                                                                          {
                                                                          (arg0,
                                                                           arg1)
                                                                          =>
                                                                          [::core::fmt::ArgumentV1::new(arg0,
                                                                                                        ::core::fmt::Display::fmt),
                                                                           ::core::fmt::ArgumentV1::new(arg1,
                                                                                                        ::core::fmt::Debug::fmt)],
                                                                      },
                                                                     &[::core::fmt::rt::v1::Argument{position:
                                                                                                         0usize,
                                                                                                     format:
                                                                                                         ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                             ' ',
                                                                                                                                         align:
                                                                                                                                             ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                         flags:
                                                                                                                                             0u32,
                                                                                                                                         precision:
                                                                                                                                             ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                         width:
                                                                                                                                             ::core::fmt::rt::v1::Count::Implied,},},
                                                                       ::core::fmt::rt::v1::Argument{position:
                                                                                                         1usize,
                                                                                                     format:
                                                                                                         ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                             ' ',
                                                                                                                                         align:
                                                                                                                                             ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                         flags:
                                                                                                                                             4u32,
                                                                                                                                         precision:
                                                                                                                                             ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                         width:
                                                                                                                                             ::core::fmt::rt::v1::Count::Implied,},}])),
                Value::Fn(fun) =>
                f.write_fmt(::core::fmt::Arguments::new_v1_formatted(&[""],
                                                                     &match (&fun,)
                                                                          {
                                                                          (arg0,)
                                                                          =>
                                                                          [::core::fmt::ArgumentV1::new(arg0,
                                                                                                        ::core::fmt::Debug::fmt)],
                                                                      },
                                                                     &[::core::fmt::rt::v1::Argument{position:
                                                                                                         0usize,
                                                                                                     format:
                                                                                                         ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                             ' ',
                                                                                                                                         align:
                                                                                                                                             ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                         flags:
                                                                                                                                             4u32,
                                                                                                                                         precision:
                                                                                                                                             ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                         width:
                                                                                                                                             ::core::fmt::rt::v1::Count::Implied,},}])),
            }
        }
    }
    impl Value {
        fn is_num(&self) -> bool {
            match self { Value::Num(_) => true, _ => false, }
        }
        fn truthy(&self) -> bool {
            match self {
                Value::Bool(b) => *b,
                _ => {
                    ::std::rt::begin_panic("Tried to check if value other than bool is truthy, this should not happen and is most definitely a bug in our typechecker!")
                }
            }
        }
    }
    pub struct Interp {
        cxt: Cxt<String, Value>,
        ty_table: HashMap<String, TyDecl>,
    }
    impl From<Lit> for Value {
        fn from(l: Lit) -> Self {
            match l {
                Lit::Number(n) => Value::Num(n),
                Lit::String(t) => {
                    let t = &t[1..t.len() - 1];
                    Value::Text(t.to_string())
                }
                Lit::Bool(b) => Value::Bool(b),
            }
        }
    }
    impl Interp {
        pub fn new() -> Self {
            Self{cxt: Cxt::new(), ty_table: HashMap::new(),}
        }
        fn run_block(&mut self, block: &mut Block)
         -> Result<Option<Value>, Diagnostic> {
            self.cxt.make();
            for stmt in block.stmts.iter_mut() {
                let ret = stmt.accept(self)?;
                if let Some(_) = ret { self.cxt.drop(); return Ok(ret); }
            }
            self.cxt.drop();
            Ok(None)
        }
        fn call_fn(&mut self, callee: &Expr, args: &Vec<Expr>)
         -> Result<Value, Diagnostic> {
            let callee = self.eval(callee)?;
            let mut args_eval = Vec::new();
            for arg in args { args_eval.push(self.eval(arg)?); }
            let mut fun =
                match callee {
                    Value::Fn(x) => x,
                    _ => {
                        let pat = "$ pat";
                        let val = "callee";
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1_formatted(&["Invalide Umwandlung, ",
                                                                                                   " entspricht nicht folgendem Muster: ",
                                                                                                   " dies ist wahrscheinlich ein Fehler im Typenchecker!"],
                                                                                                 &match (&val,
                                                                                                         &pat)
                                                                                                      {
                                                                                                      (arg0,
                                                                                                       arg1)
                                                                                                      =>
                                                                                                      [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                    ::core::fmt::Debug::fmt),
                                                                                                       ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                    ::core::fmt::Debug::fmt)],
                                                                                                  },
                                                                                                 &[::core::fmt::rt::v1::Argument{position:
                                                                                                                                     0usize,
                                                                                                                                 format:
                                                                                                                                     ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                         ' ',
                                                                                                                                                                     align:
                                                                                                                                                                         ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                     flags:
                                                                                                                                                                         4u32,
                                                                                                                                                                     precision:
                                                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                     width:
                                                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,},},
                                                                                                   ::core::fmt::rt::v1::Argument{position:
                                                                                                                                     1usize,
                                                                                                                                 format:
                                                                                                                                     ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                         ' ',
                                                                                                                                                                     align:
                                                                                                                                                                         ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                     flags:
                                                                                                                                                                         4u32,
                                                                                                                                                                     precision:
                                                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                     width:
                                                                                                                                                                         ::core::fmt::rt::v1::Count::Implied,},}]))
                        };
                    }
                };
            let params = fun.header.params;
            if true {
                {
                    match (&args_eval.len(), &params.len()) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                {
                                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["assertion failed: `(left == right)`\n  left: `",
                                                                                                 "`,\n right: `",
                                                                                                 "`"],
                                                                                               &match (&&*left_val,
                                                                                                       &&*right_val)
                                                                                                    {
                                                                                                    (arg0,
                                                                                                     arg1)
                                                                                                    =>
                                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                  ::core::fmt::Debug::fmt),
                                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                  ::core::fmt::Debug::fmt)],
                                                                                                }))
                                }
                            }
                        }
                    }
                };
            };
            self.cxt.make();
            for (p, a) in params.iter().zip(args_eval.into_iter()) {
                let name = p.name.lexeme.clone();
                self.cxt.insert(name, a);
            }
            let ret = self.run_block(&mut fun.body)?;
            self.cxt.drop();
            match ret {
                Some(val) => Ok(val),
                None => Ok(Value::Tup(Vec::new())),
            }
        }
        pub fn eval(&mut self, e: &Expr) -> Result<Value, Diagnostic> {
            match e.node {
                ExprKind::Binary { ref lhs, ref op, ref rhs } => {
                    let lhs = self.eval(lhs)?;
                    let rhs = self.eval(rhs)?;
                    match (lhs, rhs) {
                        (Value::Num(a), Value::Num(b)) =>
                        match op {
                            BinaryOp::Plus => Ok(Value::Num(a + b)),
                            BinaryOp::Minus => Ok(Value::Num(a - b)),
                            BinaryOp::Multiply => Ok(Value::Num(a * b)),
                            BinaryOp::Divide => Ok(Value::Num(a / b)),
                        },
                        _ => {
                            ::std::rt::begin_panic("error in typechecker: Invalid type for binary op!")
                        }
                    }
                }
                ExprKind::Logical { ref lhs, ref op, ref rhs } => {
                    let lhs = self.eval(lhs)?;
                    let rhs = self.eval(rhs)?;
                    match op {
                        CmpOp::EqEq => Ok(Value::Bool(lhs == rhs)),
                        CmpOp::NotEq => Ok(Value::Bool(lhs != rhs)),
                        CmpOp::Greater =>
                        match (lhs, rhs) {
                            (Value::Num(a), Value::Num(b)) =>
                            Ok(Value::Bool(a > b)),
                            _ => {
                                ::std::rt::begin_panic("error in typechecker: Invalid type for cmpop: >")
                            }
                        },
                        CmpOp::GreaterEq =>
                        match (lhs, rhs) {
                            (Value::Num(a), Value::Num(b)) =>
                            Ok(Value::Bool(a >= b)),
                            _ => {
                                ::std::rt::begin_panic("error in typechecker: Invalid type for cmpop: >=")
                            }
                        },
                        CmpOp::Less =>
                        match (lhs, rhs) {
                            (Value::Num(a), Value::Num(b)) =>
                            Ok(Value::Bool(a < b)),
                            _ => {
                                ::std::rt::begin_panic("error in typechecker: Invalid type for cmpop: <")
                            }
                        },
                        CmpOp::LessEq =>
                        match (lhs, rhs) {
                            (Value::Num(a), Value::Num(b)) =>
                            Ok(Value::Bool(a <= b)),
                            _ => {
                                ::std::rt::begin_panic("error in typechecker: Invalid type for cmpop: <=")
                            }
                        },
                        CmpOp::And =>
                        match (lhs, rhs) {
                            (Value::Bool(a), Value::Bool(b)) =>
                            Ok(Value::Bool(a && b)),
                            _ => {
                                ::std::rt::begin_panic("error in typechecker: Invalid type for cmpop: and")
                            }
                        },
                        CmpOp::Or =>
                        match (lhs, rhs) {
                            (Value::Bool(a), Value::Bool(b)) =>
                            Ok(Value::Bool(a || b)),
                            _ => {
                                ::std::rt::begin_panic("error in typechecker: Invalid type for cmpop: or")
                            }
                        },
                    }
                }
                ExprKind::Unary { ref rhs, ref op } =>
                match op {
                    UnaryOp::Minus => {
                        if let Value::Num(n) = self.eval(rhs)? {
                            return Ok(Value::Num(-1.0 * n));
                        } else {
                            {
                                ::std::rt::begin_panic("error in typechecker: Invalid type for unary: -")
                            };
                        }
                    }
                    UnaryOp::Not => {
                        if let Value::Bool(b) = self.eval(rhs)? {
                            return Ok(Value::Bool(!b));
                        } else {
                            {
                                ::std::rt::begin_panic("error in typechecker: Invalid type for unary: !")
                            };
                        }
                    }
                },
                ExprKind::Lit(ref l) => Ok(l.clone().into()),
                ExprKind::Path(ref p) => {
                    if p.len() > 1 {
                        { ::std::rt::begin_panic("not yet implemented") }
                    } else {
                        let name = &p.first().unwrap().lexeme;
                        if true {
                            if !self.cxt.get(&name).is_some() {
                                {
                                    ::std::rt::begin_panic("Fehlende Variablen sollten eigentlich vom Typchecker erkannt werden!")
                                }
                            };
                        };
                        Ok(self.cxt.get(&name).unwrap().clone())
                    }
                }
                ExprKind::Struct { ref name, ref members } => {
                    let mut obj = HashMap::new();
                    for field in members.iter() {
                        let name = field.name.lexeme.clone();
                        let val = self.eval(&field.init.clone())?;
                        obj.insert(name, val);
                    }
                    Ok(Value::Object(name.clone(), obj))
                }
                ExprKind::Tup(ref elems) => {
                    let mut t = Vec::new();
                    for e in elems { t.push(self.eval(&e)?); }
                    Ok(Value::Tup(t))
                }
                ExprKind::Array(ref arr) => {
                    let mut a = Vec::new();
                    for e in arr { a.push(self.eval(&e)?); }
                    Ok(Value::Array(a))
                }
                ExprKind::Range(ref start, ref end) => {
                    let (start, end) =
                        match (self.eval(start)?, self.eval(end)?) {
                            (Value::Num(start), Value::Num(end)) =>
                            (start, end),
                            _ => {
                                ::std::rt::begin_panic("Start und Endwert einer Reihe muessen immer den Typ Zahl haben. Es scheint als haetten wir einen Fehler im Typchecker!")
                            }
                        };
                    let (start, end) = (start as i64, end as i64);
                    let range =
                        (start..end).map(|i| Value::Num(i as f64)).collect();
                    Ok(Value::Array(range))
                }
                ExprKind::Index { ref callee, ref index } =>
                match (self.eval(callee)?, self.eval(index)?) {
                    (Value::Array(arr), Value::Num(i)) => {
                        let i = i.trunc() as usize;
                        match arr.get(i) {
                            Some(v) => Ok(v.clone()),
                            None => {
                                ::std::rt::begin_panic("index out of bounds!")
                            }
                        }
                    }
                    _ => {
                        ::std::rt::begin_panic("Fehler im Typchecker. Index must be of type callee: array and index: num!")
                    }
                },
                ExprKind::Field(ref callee, ref field) =>
                match self.eval(callee)? {
                    Value::Object(_, obj) =>
                    Ok(obj.get(&field.lexeme).unwrap().clone()),
                    _ => {
                        ::std::rt::begin_panic("error in the typechecker!")
                    }
                },
                ExprKind::This =>
                Ok(self.cxt.get(&"selbst".to_string()).unwrap().clone()),
                ExprKind::Call { ref callee, ref args } =>
                self.call_fn(&callee, &args),
                ExprKind::Val(ref v) => Ok(v.clone()),
                ExprKind::Intrinsic { ref kind, ref args } =>
                match kind {
                    Intrinsic::Print => {
                        let mut args_eval = Vec::new();
                        for arg in args { args_eval.push(self.eval(arg)?); }
                        {
                            ::std::io::_print(::core::fmt::Arguments::new_v1(&["",
                                                                               "\n"],
                                                                             &match (&args_eval[0],)
                                                                                  {
                                                                                  (arg0,)
                                                                                  =>
                                                                                  [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                ::core::fmt::Display::fmt)],
                                                                              }));
                        };
                        Ok(Value::Num(0.0))
                    }
                    _ => { ::std::rt::begin_panic("not yet implemented") }
                },
            }
        }
        fn fill_fn_table(&mut self, ast: &mut AST) {
            for decl in ast {
                if let Decl::Fn(f) = decl {
                    let name = f.header.name.lexeme.clone();
                    self.cxt.insert(name, Value::Fn(f.clone()));
                }
            }
        }
        fn fill_ty_table(&mut self, ast: &mut AST) {
            for decl in ast {
                if let Decl::TyDecl(t) = decl {
                    let name = t.name().lexeme.clone();
                    self.ty_table.insert(name, t.clone());
                }
            }
        }
        pub fn interp(&mut self, ast: &mut AST) {
            self.fill_fn_table(ast);
            self.fill_ty_table(ast);
            for d in ast.iter_mut() {
                if let Decl::Fn(f) = d {
                    if f.header.name.lexeme == "Start" {
                        self.run_block(&mut f.body);
                    }
                }
            }
        }
    }
    impl Visitor for Interp {
        type Result = Result<Option<Value>, Diagnostic>;
        fn visit_decl(&mut self, d: &mut Decl) -> Self::Result {
            { ::std::rt::begin_panic("not yet implemented") }
        }
        fn visit_expr(&mut self, e: &mut Expr) -> Self::Result {
            Ok(Some(self.eval(e)?))
        }
        fn visit_stmt(&mut self, s: &mut Stmt) -> Self::Result {
            match s {
                Stmt::VarDef(ref v) => {
                    let val = self.eval(&v.init)?;
                    let name = &v.pat.lexeme;
                    self.cxt.insert(name.clone(), val);
                    Ok(None)
                }
                Stmt::If {
                ref cond,
                ref mut body,
                ref mut else_branches,
                ref mut final_branch,
                ref span } => {
                    if self.eval(cond)?.truthy() {
                        let ret = self.run_block(body)?;
                        if let Some(_) = ret { return Ok(ret); }
                    } else {
                        for branch in else_branches.iter_mut() {
                            if self.eval(&branch.cond)?.truthy() {
                                self.run_block(&mut branch.body)?;
                                return Ok(None);
                            }
                        }
                        if let Some(fb) = final_branch {
                            let ret = self.run_block(&mut fb.body)?;
                            if let Some(_) = ret { return Ok(ret); }
                        }
                    }
                    Ok(None)
                }
                Stmt::For { ref vardef, ref mut body, ref span } => {
                    self.cxt.make();
                    let val = self.eval(&vardef.init)?;
                    let loop_var = vardef.pat.lexeme.clone();
                    let arr =
                        match val {
                            Value::Array(a) => a,
                            _ => {
                                ::std::rt::begin_panic("We can only iterate through arrays! If you are starring at this message trying to understand what happend, don't worry, this is most likely a bug in the typechecker!")
                            }
                        };
                    for elem in arr {
                        self.cxt.insert(loop_var.clone(), elem);
                        let ret = self.run_block(body)?;
                        if let Some(_) = ret {
                            self.cxt.drop();
                            return Ok(ret);
                        }
                    }
                    self.cxt.drop();
                    Ok(None)
                }
                Stmt::Expr(ref e) => { self.eval(e)?; Ok(None) }
                Stmt::While { ref cond, ref mut body, ref span } => {
                    while self.eval(cond)?.truthy() {
                        let ret = self.run_block(body)?;
                        if let Some(_) = ret { return Ok(ret); }
                    }
                    Ok(None)
                }
                Stmt::Assign { ref lhs, ref rhs, ref span } => {
                    {
                        ::std::io::_print(::core::fmt::Arguments::new_v1(&["bevor eval\n"],
                                                                         &match ()
                                                                              {
                                                                              ()
                                                                              =>
                                                                              [],
                                                                          }));
                    };
                    match lhs {
                        tmp => {
                            {
                                ::std::io::_eprint(::core::fmt::Arguments::new_v1_formatted(&["[",
                                                                                              ":",
                                                                                              "] ",
                                                                                              " = ",
                                                                                              "\n"],
                                                                                            &match (&"src/interp.rs",
                                                                                                    &461u32,
                                                                                                    &"lhs",
                                                                                                    &&tmp)
                                                                                                 {
                                                                                                 (arg0,
                                                                                                  arg1,
                                                                                                  arg2,
                                                                                                  arg3)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                               ::core::fmt::Debug::fmt)],
                                                                                             },
                                                                                            &[::core::fmt::rt::v1::Argument{position:
                                                                                                                                0usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                1usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                2usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                3usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    4u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},}]));
                            };
                            tmp
                        }
                    };
                    match rhs {
                        tmp => {
                            {
                                ::std::io::_eprint(::core::fmt::Arguments::new_v1_formatted(&["[",
                                                                                              ":",
                                                                                              "] ",
                                                                                              " = ",
                                                                                              "\n"],
                                                                                            &match (&"src/interp.rs",
                                                                                                    &462u32,
                                                                                                    &"rhs",
                                                                                                    &&tmp)
                                                                                                 {
                                                                                                 (arg0,
                                                                                                  arg1,
                                                                                                  arg2,
                                                                                                  arg3)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                               ::core::fmt::Debug::fmt)],
                                                                                             },
                                                                                            &[::core::fmt::rt::v1::Argument{position:
                                                                                                                                0usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                1usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                2usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                3usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    4u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},}]));
                            };
                            tmp
                        }
                    };
                    let lhs = self.eval(lhs)?;
                    let rhs = self.eval(rhs)?;
                    {
                        ::std::io::_print(::core::fmt::Arguments::new_v1(&["after eval\n"],
                                                                         &match ()
                                                                              {
                                                                              ()
                                                                              =>
                                                                              [],
                                                                          }));
                    };
                    match lhs {
                        tmp => {
                            {
                                ::std::io::_eprint(::core::fmt::Arguments::new_v1_formatted(&["[",
                                                                                              ":",
                                                                                              "] ",
                                                                                              " = ",
                                                                                              "\n"],
                                                                                            &match (&"src/interp.rs",
                                                                                                    &467u32,
                                                                                                    &"lhs",
                                                                                                    &&tmp)
                                                                                                 {
                                                                                                 (arg0,
                                                                                                  arg1,
                                                                                                  arg2,
                                                                                                  arg3)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                               ::core::fmt::Debug::fmt)],
                                                                                             },
                                                                                            &[::core::fmt::rt::v1::Argument{position:
                                                                                                                                0usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                1usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                2usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                3usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    4u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},}]));
                            };
                            tmp
                        }
                    };
                    match rhs {
                        tmp => {
                            {
                                ::std::io::_eprint(::core::fmt::Arguments::new_v1_formatted(&["[",
                                                                                              ":",
                                                                                              "] ",
                                                                                              " = ",
                                                                                              "\n"],
                                                                                            &match (&"src/interp.rs",
                                                                                                    &468u32,
                                                                                                    &"rhs",
                                                                                                    &&tmp)
                                                                                                 {
                                                                                                 (arg0,
                                                                                                  arg1,
                                                                                                  arg2,
                                                                                                  arg3)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                               ::core::fmt::Display::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                               ::core::fmt::Debug::fmt)],
                                                                                             },
                                                                                            &[::core::fmt::rt::v1::Argument{position:
                                                                                                                                0usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                1usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                2usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    0u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},},
                                                                                              ::core::fmt::rt::v1::Argument{position:
                                                                                                                                3usize,
                                                                                                                            format:
                                                                                                                                ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                    ' ',
                                                                                                                                                                align:
                                                                                                                                                                    ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                flags:
                                                                                                                                                                    4u32,
                                                                                                                                                                precision:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                                width:
                                                                                                                                                                    ::core::fmt::rt::v1::Count::Implied,},}]));
                            };
                            tmp
                        }
                    };
                    { ::std::rt::begin_panic("not yet implemented") };
                }
                Stmt::Block(ref mut block) => Ok(self.run_block(block)?),
                Stmt::Break(_) | Stmt::Continue(_) => {
                    ::std::rt::begin_panic("not yet implemented")
                }
                Stmt::Ret(ref e, _) => Ok(Some(self.eval(e)?)),
            }
        }
    }
}
mod lexer {
    use std::fmt;
    use std::iter::*;
    use std::str::Chars;
    use std::str::FromStr;
    use super::errors::*;
    use crate::ast::Span;
    use itertools::multipeek;
    use itertools::*;
    type LexResult = Result<Token, Diagnostic>;
    type LexKindResult = Result<TokenKind, Diagnostic>;
    pub enum TokenKind {
        Ident(String),
        Keyword(Keyword),
        Comment,
        Lit(Lit),
        PathSep,
        Sep,
        Nl,
        LBrace,
        RBrace,
        LParen,
        RParen,
        LBracket,
        RBracket,
        Dollar,
        Colon,
        Dot,
        Comma,
        Eq,
        Operator(Operator),
        Semi,
        Underscore,
        ColonEq,
        ThinArrow,
        FatArrow,
        EOF,
    }
    impl ::core::marker::StructuralPartialEq for TokenKind { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenKind {
        #[inline]
        fn eq(&self, other: &TokenKind) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TokenKind::Ident(ref __self_0),
                         &TokenKind::Ident(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&TokenKind::Keyword(ref __self_0),
                         &TokenKind::Keyword(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&TokenKind::Lit(ref __self_0),
                         &TokenKind::Lit(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&TokenKind::Operator(ref __self_0),
                         &TokenKind::Operator(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &TokenKind) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TokenKind::Ident(ref __self_0),
                         &TokenKind::Ident(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&TokenKind::Keyword(ref __self_0),
                         &TokenKind::Keyword(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&TokenKind::Lit(ref __self_0),
                         &TokenKind::Lit(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&TokenKind::Operator(ref __self_0),
                         &TokenKind::Operator(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else { true }
            }
        }
    }
    impl ::core::marker::StructuralEq for TokenKind { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenKind {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<Keyword>;
                let _: ::core::cmp::AssertParamIsEq<Lit>;
                let _: ::core::cmp::AssertParamIsEq<Operator>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TokenKind::Ident(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Ident");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TokenKind::Keyword(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Keyword");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TokenKind::Comment,) => {
                    let mut debug_trait_builder = f.debug_tuple("Comment");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Lit(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Lit");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TokenKind::PathSep,) => {
                    let mut debug_trait_builder = f.debug_tuple("PathSep");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Sep,) => {
                    let mut debug_trait_builder = f.debug_tuple("Sep");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Nl,) => {
                    let mut debug_trait_builder = f.debug_tuple("Nl");
                    debug_trait_builder.finish()
                }
                (&TokenKind::LBrace,) => {
                    let mut debug_trait_builder = f.debug_tuple("LBrace");
                    debug_trait_builder.finish()
                }
                (&TokenKind::RBrace,) => {
                    let mut debug_trait_builder = f.debug_tuple("RBrace");
                    debug_trait_builder.finish()
                }
                (&TokenKind::LParen,) => {
                    let mut debug_trait_builder = f.debug_tuple("LParen");
                    debug_trait_builder.finish()
                }
                (&TokenKind::RParen,) => {
                    let mut debug_trait_builder = f.debug_tuple("RParen");
                    debug_trait_builder.finish()
                }
                (&TokenKind::LBracket,) => {
                    let mut debug_trait_builder = f.debug_tuple("LBracket");
                    debug_trait_builder.finish()
                }
                (&TokenKind::RBracket,) => {
                    let mut debug_trait_builder = f.debug_tuple("RBracket");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Dollar,) => {
                    let mut debug_trait_builder = f.debug_tuple("Dollar");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Colon,) => {
                    let mut debug_trait_builder = f.debug_tuple("Colon");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Dot,) => {
                    let mut debug_trait_builder = f.debug_tuple("Dot");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Comma,) => {
                    let mut debug_trait_builder = f.debug_tuple("Comma");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Eq,) => {
                    let mut debug_trait_builder = f.debug_tuple("Eq");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Operator(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Operator");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TokenKind::Semi,) => {
                    let mut debug_trait_builder = f.debug_tuple("Semi");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Underscore,) => {
                    let mut debug_trait_builder = f.debug_tuple("Underscore");
                    debug_trait_builder.finish()
                }
                (&TokenKind::ColonEq,) => {
                    let mut debug_trait_builder = f.debug_tuple("ColonEq");
                    debug_trait_builder.finish()
                }
                (&TokenKind::ThinArrow,) => {
                    let mut debug_trait_builder = f.debug_tuple("ThinArrow");
                    debug_trait_builder.finish()
                }
                (&TokenKind::FatArrow,) => {
                    let mut debug_trait_builder = f.debug_tuple("FatArrow");
                    debug_trait_builder.finish()
                }
                (&TokenKind::EOF,) => {
                    let mut debug_trait_builder = f.debug_tuple("EOF");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenKind {
        #[inline]
        fn clone(&self) -> TokenKind {
            match (&*self,) {
                (&TokenKind::Ident(ref __self_0),) =>
                TokenKind::Ident(::core::clone::Clone::clone(&(*__self_0))),
                (&TokenKind::Keyword(ref __self_0),) =>
                TokenKind::Keyword(::core::clone::Clone::clone(&(*__self_0))),
                (&TokenKind::Comment,) => TokenKind::Comment,
                (&TokenKind::Lit(ref __self_0),) =>
                TokenKind::Lit(::core::clone::Clone::clone(&(*__self_0))),
                (&TokenKind::PathSep,) => TokenKind::PathSep,
                (&TokenKind::Sep,) => TokenKind::Sep,
                (&TokenKind::Nl,) => TokenKind::Nl,
                (&TokenKind::LBrace,) => TokenKind::LBrace,
                (&TokenKind::RBrace,) => TokenKind::RBrace,
                (&TokenKind::LParen,) => TokenKind::LParen,
                (&TokenKind::RParen,) => TokenKind::RParen,
                (&TokenKind::LBracket,) => TokenKind::LBracket,
                (&TokenKind::RBracket,) => TokenKind::RBracket,
                (&TokenKind::Dollar,) => TokenKind::Dollar,
                (&TokenKind::Colon,) => TokenKind::Colon,
                (&TokenKind::Dot,) => TokenKind::Dot,
                (&TokenKind::Comma,) => TokenKind::Comma,
                (&TokenKind::Eq,) => TokenKind::Eq,
                (&TokenKind::Operator(ref __self_0),) =>
                TokenKind::Operator(::core::clone::Clone::clone(&(*__self_0))),
                (&TokenKind::Semi,) => TokenKind::Semi,
                (&TokenKind::Underscore,) => TokenKind::Underscore,
                (&TokenKind::ColonEq,) => TokenKind::ColonEq,
                (&TokenKind::ThinArrow,) => TokenKind::ThinArrow,
                (&TokenKind::FatArrow,) => TokenKind::FatArrow,
                (&TokenKind::EOF,) => TokenKind::EOF,
            }
        }
    }
    impl fmt::Display for TokenKind {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let str =
                match self {
                    TokenKind::Ident(id) => id,
                    TokenKind::Keyword(kw) => kw.as_str(),
                    TokenKind::Comment => "//",
                    TokenKind::Lit(l) => l.as_str(),
                    TokenKind::PathSep => "::",
                    TokenKind::Nl => "Zeilenumbruch",
                    TokenKind::LBrace => "{",
                    TokenKind::RBrace => "}",
                    TokenKind::LParen => "(",
                    TokenKind::RParen => ")",
                    TokenKind::LBracket => "[",
                    TokenKind::RBracket => "]",
                    TokenKind::Dollar => "$",
                    TokenKind::Sep => "|",
                    TokenKind::Colon => ":",
                    TokenKind::Comma => ",",
                    TokenKind::Dot => ".",
                    TokenKind::Eq => "=",
                    TokenKind::Operator(op) => op.as_str(),
                    TokenKind::Semi => ",",
                    TokenKind::Underscore => "_",
                    TokenKind::ColonEq => ":=",
                    TokenKind::ThinArrow => "->",
                    TokenKind::FatArrow => "=>",
                    TokenKind::EOF => "EOF",
                };
            f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                       &match (&str,) {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    pub enum Operator {
        Plus,
        Minus,
        Slash,
        Star,
        Range,
        Not,
        And,
        Or,
        EqEq,
        NotEq,
        Greater,
        GreaterEq,
        Less,
        LessEq,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Operator {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Operator::Plus,) => {
                    let mut debug_trait_builder = f.debug_tuple("Plus");
                    debug_trait_builder.finish()
                }
                (&Operator::Minus,) => {
                    let mut debug_trait_builder = f.debug_tuple("Minus");
                    debug_trait_builder.finish()
                }
                (&Operator::Slash,) => {
                    let mut debug_trait_builder = f.debug_tuple("Slash");
                    debug_trait_builder.finish()
                }
                (&Operator::Star,) => {
                    let mut debug_trait_builder = f.debug_tuple("Star");
                    debug_trait_builder.finish()
                }
                (&Operator::Range,) => {
                    let mut debug_trait_builder = f.debug_tuple("Range");
                    debug_trait_builder.finish()
                }
                (&Operator::Not,) => {
                    let mut debug_trait_builder = f.debug_tuple("Not");
                    debug_trait_builder.finish()
                }
                (&Operator::And,) => {
                    let mut debug_trait_builder = f.debug_tuple("And");
                    debug_trait_builder.finish()
                }
                (&Operator::Or,) => {
                    let mut debug_trait_builder = f.debug_tuple("Or");
                    debug_trait_builder.finish()
                }
                (&Operator::EqEq,) => {
                    let mut debug_trait_builder = f.debug_tuple("EqEq");
                    debug_trait_builder.finish()
                }
                (&Operator::NotEq,) => {
                    let mut debug_trait_builder = f.debug_tuple("NotEq");
                    debug_trait_builder.finish()
                }
                (&Operator::Greater,) => {
                    let mut debug_trait_builder = f.debug_tuple("Greater");
                    debug_trait_builder.finish()
                }
                (&Operator::GreaterEq,) => {
                    let mut debug_trait_builder = f.debug_tuple("GreaterEq");
                    debug_trait_builder.finish()
                }
                (&Operator::Less,) => {
                    let mut debug_trait_builder = f.debug_tuple("Less");
                    debug_trait_builder.finish()
                }
                (&Operator::LessEq,) => {
                    let mut debug_trait_builder = f.debug_tuple("LessEq");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Operator { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Operator {
        #[inline]
        fn eq(&self, other: &Operator) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    impl ::core::marker::StructuralEq for Operator { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Operator {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () { { } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Operator {
        #[inline]
        fn clone(&self) -> Operator {
            match (&*self,) {
                (&Operator::Plus,) => Operator::Plus,
                (&Operator::Minus,) => Operator::Minus,
                (&Operator::Slash,) => Operator::Slash,
                (&Operator::Star,) => Operator::Star,
                (&Operator::Range,) => Operator::Range,
                (&Operator::Not,) => Operator::Not,
                (&Operator::And,) => Operator::And,
                (&Operator::Or,) => Operator::Or,
                (&Operator::EqEq,) => Operator::EqEq,
                (&Operator::NotEq,) => Operator::NotEq,
                (&Operator::Greater,) => Operator::Greater,
                (&Operator::GreaterEq,) => Operator::GreaterEq,
                (&Operator::Less,) => Operator::Less,
                (&Operator::LessEq,) => Operator::LessEq,
            }
        }
    }
    impl Operator {
        fn as_str(&self) -> &'static str {
            match self {
                Operator::Plus => "+",
                Operator::Minus => "-",
                Operator::Star => "*",
                Operator::Slash => "/",
                Operator::Range => "bis",
                Operator::And => "und",
                Operator::Or => "oder",
                Operator::Not => "nicht",
                Operator::EqEq => "gleich",
                Operator::NotEq => "ungleich",
                Operator::GreaterEq => ">=",
                Operator::Greater => ">",
                Operator::LessEq => "<=",
                Operator::Less => "<",
            }
        }
    }
    impl fmt::Display for Operator {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                       &match (&self.as_str(),)
                                                            {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    impl FromStr for Operator {
        type Err = ();
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "+" => Ok(Operator::Plus),
                "-" => Ok(Operator::Minus),
                "*" => Ok(Operator::Star),
                "/" => Ok(Operator::Slash),
                ".." | "bis" => Ok(Operator::Range),
                "nicht" | "!" => Ok(Operator::Not),
                "und" | "&&" => Ok(Operator::And),
                "oder" | "||" => Ok(Operator::Or),
                "ungleich" | "!=" => Ok(Operator::NotEq),
                "gleich" | "==" => Ok(Operator::EqEq),
                "groesser_gleich" | ">=" => Ok(Operator::GreaterEq),
                "groesser" | ">" => Ok(Operator::Greater),
                "kleiner" | "<" => Ok(Operator::Less),
                "kleiner_gleich" | "<=" => Ok(Operator::LessEq),
                _ => Err(()),
            }
        }
    }
    pub enum Lit { String(String), Number(f64), Bool(bool), }
    impl ::core::marker::StructuralPartialEq for Lit { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Lit {
        #[inline]
        fn eq(&self, other: &Lit) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Lit::String(ref __self_0),
                         &Lit::String(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Lit::Number(ref __self_0),
                         &Lit::Number(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Lit::Bool(ref __self_0), &Lit::Bool(ref __arg_1_0))
                        => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &Lit) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Lit::String(ref __self_0),
                         &Lit::String(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Lit::Number(ref __self_0),
                         &Lit::Number(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Lit::Bool(ref __self_0), &Lit::Bool(ref __arg_1_0))
                        => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Lit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Lit::String(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("String");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Lit::Number(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Number");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Lit::Bool(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Bool");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Lit {
        #[inline]
        fn clone(&self) -> Lit {
            match (&*self,) {
                (&Lit::String(ref __self_0),) =>
                Lit::String(::core::clone::Clone::clone(&(*__self_0))),
                (&Lit::Number(ref __self_0),) =>
                Lit::Number(::core::clone::Clone::clone(&(*__self_0))),
                (&Lit::Bool(ref __self_0),) =>
                Lit::Bool(::core::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    impl Eq for Lit { }
    impl Lit {
        fn as_str(&self) -> &'static str {
            match self {
                Self::String(_) => "Textliteral",
                Self::Number(_) => "Zahlenliteral",
                Self::Bool(_) => "Boolliteral",
            }
        }
    }
    impl FromStr for Lit {
        type Err = ();
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "wahr" => Ok(Self::Bool(true)),
                "falsch" => Ok(Self::Bool(false)),
                _ => Err(()),
            }
        }
    }
    pub enum Keyword {
        Fun,
        Struct,
        Impl,
        This,
        While,
        Return,
        For,
        Break,
        Continue,
        If,
        Then,
        Else,
        Read,
        Write,
        Print,
    }
    impl ::core::marker::StructuralPartialEq for Keyword { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Keyword {
        #[inline]
        fn eq(&self, other: &Keyword) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Keyword {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Keyword::Fun,) => {
                    let mut debug_trait_builder = f.debug_tuple("Fun");
                    debug_trait_builder.finish()
                }
                (&Keyword::Struct,) => {
                    let mut debug_trait_builder = f.debug_tuple("Struct");
                    debug_trait_builder.finish()
                }
                (&Keyword::Impl,) => {
                    let mut debug_trait_builder = f.debug_tuple("Impl");
                    debug_trait_builder.finish()
                }
                (&Keyword::This,) => {
                    let mut debug_trait_builder = f.debug_tuple("This");
                    debug_trait_builder.finish()
                }
                (&Keyword::While,) => {
                    let mut debug_trait_builder = f.debug_tuple("While");
                    debug_trait_builder.finish()
                }
                (&Keyword::Return,) => {
                    let mut debug_trait_builder = f.debug_tuple("Return");
                    debug_trait_builder.finish()
                }
                (&Keyword::For,) => {
                    let mut debug_trait_builder = f.debug_tuple("For");
                    debug_trait_builder.finish()
                }
                (&Keyword::Break,) => {
                    let mut debug_trait_builder = f.debug_tuple("Break");
                    debug_trait_builder.finish()
                }
                (&Keyword::Continue,) => {
                    let mut debug_trait_builder = f.debug_tuple("Continue");
                    debug_trait_builder.finish()
                }
                (&Keyword::If,) => {
                    let mut debug_trait_builder = f.debug_tuple("If");
                    debug_trait_builder.finish()
                }
                (&Keyword::Then,) => {
                    let mut debug_trait_builder = f.debug_tuple("Then");
                    debug_trait_builder.finish()
                }
                (&Keyword::Else,) => {
                    let mut debug_trait_builder = f.debug_tuple("Else");
                    debug_trait_builder.finish()
                }
                (&Keyword::Read,) => {
                    let mut debug_trait_builder = f.debug_tuple("Read");
                    debug_trait_builder.finish()
                }
                (&Keyword::Write,) => {
                    let mut debug_trait_builder = f.debug_tuple("Write");
                    debug_trait_builder.finish()
                }
                (&Keyword::Print,) => {
                    let mut debug_trait_builder = f.debug_tuple("Print");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for Keyword { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Keyword {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () { { } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Keyword {
        #[inline]
        fn clone(&self) -> Keyword {
            match (&*self,) {
                (&Keyword::Fun,) => Keyword::Fun,
                (&Keyword::Struct,) => Keyword::Struct,
                (&Keyword::Impl,) => Keyword::Impl,
                (&Keyword::This,) => Keyword::This,
                (&Keyword::While,) => Keyword::While,
                (&Keyword::Return,) => Keyword::Return,
                (&Keyword::For,) => Keyword::For,
                (&Keyword::Break,) => Keyword::Break,
                (&Keyword::Continue,) => Keyword::Continue,
                (&Keyword::If,) => Keyword::If,
                (&Keyword::Then,) => Keyword::Then,
                (&Keyword::Else,) => Keyword::Else,
                (&Keyword::Read,) => Keyword::Read,
                (&Keyword::Write,) => Keyword::Write,
                (&Keyword::Print,) => Keyword::Print,
            }
        }
    }
    impl Keyword {
        fn as_str(&self) -> &'static str {
            match self {
                Keyword::Fun => "fun",
                Keyword::Struct => "typ",
                Keyword::Impl => "implementiere",
                Keyword::This => "selbst",
                Keyword::While => "solange",
                Keyword::Return => "rueckgabe",
                Keyword::For => "fuer",
                Keyword::Continue => "weiter",
                Keyword::Break => "stop",
                Keyword::If => "wenn",
                Keyword::Then => "dann",
                Keyword::Else => "sonst",
                Keyword::Print => "#ausgabe",
                Keyword::Read => "#lese",
                Keyword::Write => "#schreibe",
            }
        }
    }
    impl fmt::Display for Keyword {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                       &match (&self.as_str(),)
                                                            {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    impl FromStr for Keyword {
        type Err = ();
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "funktion" | "fun" | "fn" => Ok(Keyword::Fun),
                "Typ" | "typ" => Ok(Keyword::Struct),
                "implementiere" | "impl" => Ok(Keyword::Impl),
                "selbst" => Ok(Keyword::This),
                "solange" => Ok(Keyword::While),
                "rueckgabe" => Ok(Keyword::Return),
                "fuer" => Ok(Keyword::For),
                "wenn" => Ok(Keyword::If),
                "dann" => Ok(Keyword::Then),
                "sonst" => Ok(Keyword::Else),
                "stop" => Ok(Keyword::Break),
                "weiter" => Ok(Keyword::Continue),
                "#lese" => Ok(Keyword::Read),
                "#schreibe" => Ok(Keyword::Write),
                "#ausgabe" => Ok(Keyword::Print),
                _ => Err(()),
            }
        }
    }
    pub struct Token {
        pub kind: TokenKind,
        pub span: Span,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Token {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Token { kind: ref __self_0_0, span: ref __self_0_1 } => {
                    let mut debug_trait_builder = f.debug_struct("Token");
                    let _ =
                        debug_trait_builder.field("kind", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("span", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Token {
        #[inline]
        fn clone(&self) -> Token {
            match *self {
                Token { kind: ref __self_0_0, span: ref __self_0_1 } =>
                Token{kind: ::core::clone::Clone::clone(&(*__self_0_0)),
                      span: ::core::clone::Clone::clone(&(*__self_0_1)),},
            }
        }
    }
    pub struct Lexer<'a> {
        iter: MultiPeek<Chars<'a>>,
        src_buf: &'a str,
        cursor: usize,
    }
    impl <'a> Lexer<'a> {
        pub fn new(data: &'a str) -> Self {
            Lexer{iter: multipeek(data.chars()), src_buf: data, cursor: 0,}
        }
        fn advance(&mut self) -> Option<char> {
            let c = self.iter.next();
            self.cursor += 1;
            c
        }
        pub fn peek(&mut self) -> Option<char> {
            let elem = self.iter.peek().cloned();
            self.iter.reset_peek();
            elem
        }
        fn peek_next(&mut self) -> Option<char> {
            self.iter.peek();
            let elem = self.iter.peek().cloned();
            self.iter.reset_peek();
            elem
        }
        fn map_if<F>(&mut self, p: F, res: TokenKind) -> Option<TokenKind>
         where F: Fn(char) -> bool {
            match self.peek() {
                Some(c) => {
                    if p(c) { self.advance()?; Some(res) } else { None }
                }
                None => None,
            }
        }
        pub fn advance_while<F>(&mut self, p: F) where F: Fn(&char) -> bool {
            while let Some(c) = self.peek() {
                if p(&c) { self.advance(); } else { break ; }
            }
        }
        fn eat_whitespace(&mut self) {
            self.advance_while(|c| should_skip(c));
        }
        pub fn scan_token(&mut self) -> Option<LexResult> {
            self.eat_whitespace();
            let start = self.cursor;
            let c = self.advance()?;
            let token_kind =
                match c {
                    '\n' => TokenKind::Nl,
                    '(' => TokenKind::LParen,
                    ')' => TokenKind::RParen,
                    '{' => TokenKind::LBrace,
                    '}' => TokenKind::RBrace,
                    '[' => TokenKind::LBracket,
                    ']' => TokenKind::RBracket,
                    ',' => TokenKind::Comma,
                    '+' => TokenKind::Operator(Operator::Plus),
                    '*' => TokenKind::Operator(Operator::Star),
                    ';' => TokenKind::Semi,
                    '$' => TokenKind::Dollar,
                    '-' =>
                    self.map_if(|p| p == '>',
                                TokenKind::ThinArrow).unwrap_or(TokenKind::Operator(Operator::Minus)),
                    '|' =>
                    self.map_if(|p| p == '|',
                                TokenKind::Operator(Operator::Or)).unwrap_or(TokenKind::Sep),
                    '!' =>
                    self.map_if(|p| p == '=',
                                TokenKind::Operator(Operator::NotEq)).unwrap_or(TokenKind::Operator(Operator::Not)),
                    '<' =>
                    self.map_if(|p| p == '=',
                                TokenKind::Operator(Operator::LessEq)).unwrap_or(TokenKind::Operator(Operator::Less)),
                    '>' =>
                    self.map_if(|p| p == '=',
                                TokenKind::Operator(Operator::GreaterEq)).unwrap_or(TokenKind::Operator(Operator::Greater)),
                    '.' =>
                    self.map_if(|p| p == '.',
                                TokenKind::Operator(Operator::Range)).unwrap_or(TokenKind::Dot),
                    '=' =>
                    match self.peek() {
                        Some('=') => {
                            self.advance()?;
                            TokenKind::Operator(Operator::EqEq)
                        }
                        Some('>') => { self.advance()?; TokenKind::FatArrow }
                        _ => TokenKind::Eq,
                    },
                    ':' =>
                    match self.peek() {
                        Some(':') => { self.advance()?; TokenKind::PathSep }
                        Some('=') => { self.advance()?; TokenKind::ColonEq }
                        _ => TokenKind::Colon,
                    },
                    '"' =>
                    match self.string(start) {
                        Ok(tk) => tk,
                        Err(err) => return Some(Err(err)),
                    },
                    '/' => {
                        if let Some('/') = self.peek() {
                            self.advance_while(|&c| c != '\n');
                            TokenKind::Comment
                        } else { TokenKind::Operator(Operator::Slash) }
                    }
                    '_' =>
                    match self.peek().unwrap() {
                        'a' ..='z' | 'A' ..='Z' => self.ident(start),
                        _ => TokenKind::Underscore,
                    },
                    _ if c.is_digit(10) =>
                    match self.number(start) {
                        Ok(tk) => tk,
                        Err(err) => return Some(Err(err)),
                    },
                    '#' => self.intrinsic_fun(start),
                    'a' ..='z' | 'A' ..='Z' => self.ident(start),
                    '&' =>
                    match self.peek() {
                        Some('&') => {
                            self.advance()?;
                            TokenKind::Operator(Operator::And)
                        }
                        _ => {
                            return Some(Err(self.span_err(ErrKind::Syntax(SyntaxErr::UnexpectedChar(c)),
                                                          start)))
                        }
                    },
                    c => {
                        return Some(Err(self.span_err(ErrKind::Syntax(SyntaxErr::UnexpectedChar(c)),
                                                      start)))
                    }
                };
            let token = self.yield_token(start, token_kind);
            Some(Ok(token))
        }
        fn yield_token(&mut self, start: usize, kind: TokenKind) -> Token {
            let span = self.yield_span(start);
            Token{kind, span,}
        }
        fn yield_span(&self, start: usize) -> Span {
            let end = start + self.cursor - 1;
            Span::new(start, end)
        }
        fn sub_string(&mut self, start: usize) -> String {
            self.src_buf[start..self.cursor].to_string()
        }
        fn string(&mut self, start: usize) -> LexKindResult {
            self.advance_while(|&c| c != '"');
            if self.is_at_end() {
                return Err(self.span_err(ErrKind::Syntax(SyntaxErr::UnterminatedString),
                                         start));
            }
            self.advance();
            let lit = self.sub_string(start);
            Ok(TokenKind::Lit(Lit::String(lit)))
        }
        fn number(&mut self, start: usize) -> LexKindResult {
            self.advance_while(|&c| c.is_digit(10));
            if let Some('.') = self.peek() {
                if let Some('.') = self.peek_next() {
                    let num =
                        self.src_buf[start..self.cursor].parse::<f64>().unwrap();
                    return Ok(TokenKind::Lit(Lit::Number(num)));
                }
                if self.peek_next().map(|c| !c.is_digit(10)).unwrap_or(true) {
                    return Err(self.span_err(ErrKind::Syntax(SyntaxErr::UnexpectedChar('.')),
                                             start));
                }
                self.advance();
                self.advance_while(|c| c.is_digit(10));
            }
            let num =
                self.src_buf[start..self.cursor].parse::<f64>().unwrap();
            Ok(TokenKind::Lit(Lit::Number(num)))
        }
        fn ident(&mut self, start: usize) -> TokenKind {
            self.advance_while(|&c|
                                   {
                                       ('a' <= c && c <= 'z') ||
                                           ('A' <= c && c <= 'Z') ||
                                           ('0' <= c && c <= '9') || c == '_'
                                   });
            let lexeme = self.sub_string(start);
            str::parse::<Keyword>(&lexeme).map(TokenKind::Keyword).or_else(|_|
                                                                               str::parse::<Operator>(&lexeme).map(TokenKind::Operator)).or_else(|_|
                                                                                                                                                     str::parse::<Lit>(&lexeme).map(TokenKind::Lit)).unwrap_or(TokenKind::Ident(lexeme))
        }
        fn intrinsic_fun(&mut self, start: usize) -> TokenKind {
            self.advance();
            self.advance_while(|&c|
                                   {
                                       ('a' <= c && c <= 'z') ||
                                           ('A' <= c && c <= 'Z') ||
                                           ('0' <= c && c <= '9') || c == '_'
                                   });
            let lexeme = self.sub_string(start);
            str::parse::<Keyword>(&lexeme).map(TokenKind::Keyword).unwrap_or(TokenKind::Ident(lexeme))
        }
        fn is_at_end(&mut self) -> bool { self.peek().is_none() }
        fn span_err(&self, kind: ErrKind, start: usize) -> Diagnostic {
            let sp = self.yield_span(start);
            Diagnostic::new(kind, Vec::new(), sp)
        }
    }
    impl Iterator for Lexer<'_> {
        type Item = LexResult;
        fn next(&mut self) -> Option<Self::Item> {
            while let Some(item) = self.scan_token() {
                match item {
                    Ok(t) if t.kind == TokenKind::Comment => (),
                    Ok(_) | Err(_) => return Some(item),
                };
            }
            None
        }
    }
    fn should_skip(c: &char) -> bool {
        if *c == '\n' { false } else { c.is_whitespace() }
    }
    pub fn infer_semis(t_stream: Vec<Token>) -> Vec<Token> {
        let mut open_paren = 0;
        let mut open_bracket = 0;
        let mut t_buf = Vec::new();
        for t in t_stream {
            match t.kind {
                TokenKind::LParen => open_paren += 1,
                TokenKind::RParen => open_paren -= 1,
                TokenKind::LBracket => open_bracket += 1,
                TokenKind::RBracket => open_bracket -= 1,
                TokenKind::Nl if open_paren == 0 && open_bracket == 0 => {
                    match t_buf.last() {
                        Some(Token { kind: TokenKind::Semi, span: _ }) |
                        Some(Token { kind: TokenKind::LBrace, span: _ }) |
                        Some(Token { kind: TokenKind::RBrace, span: _ }) |
                        Some(Token { kind: TokenKind::Comma, span: _ }) | None
                        => continue ,
                        _ => { }
                    };
                    t_buf.push(Token{kind: TokenKind::Semi, span: t.span,});
                    continue ;
                }
                TokenKind::Nl => continue ,
                _ => { }
            }
            t_buf.push(t)
        }
        t_buf
    }
}
mod lowering {
    use crate::ast::*;
    use crate::errors::*;
    use std::collections::HashMap;
    pub struct ImplReoderPass {
        err: Vec<Diagnostic>,
    }
    impl <'a> ImplReoderPass {
        pub fn new() -> Self { Self{err: Vec::new(),} }
        fn span_err(&mut self, kind: ErrKind, span: Span) {
            self.err.push(Diagnostic{kind, span, suggestions: Vec::new(),});
        }
    }
    pub fn reorder(ast: &mut AST) {
        let mut impls = HashMap::new();
        {
            for stmt in ast.iter() {
                if let Decl::Impl { ref target, ref fn_decls, span: _ } = stmt
                   {
                    let name = target.first().unwrap().lexeme.clone();
                    let fns = fn_decls.clone();
                    impls.insert(name, fns);
                }
            }
            for stmt in ast.iter_mut() {
                if let Decl::TyDecl(t) = stmt {
                    if let Some(methods) = impls.remove(&t.name().lexeme) {
                        t.add_methods(methods);
                    }
                }
            }
            if !impls.is_empty() {
                {
                    ::std::rt::begin_panic("TODO(Simon): report error for invalid impls on unknown types")
                };
            }
        }
    }
}
mod parser {
    use std::collections::HashMap;
    use std::convert::TryInto;
    use std::iter::*;
    use std::vec::IntoIter;
    use itertools::multipeek;
    use itertools::*;
    use crate::ast::*;
    use crate::errors::*;
    use crate::lexer::*;
    use crate::typer::{Ty, TyKind};
    type ParseResult<T> = Result<T, Diagnostic>;
    pub struct Parser {
        iter: MultiPeek<IntoIter<Token>>,
        last: Option<Token>,
    }
    /// `FnParsingMode` tells the `parse_fn_decl()` if we are allowed to have a `self` param in the function signature.
    /// If we parse an associated function in an impl Block, we pass the type which the impl block implements as an value
    /// in Method. During fn_signature_parsing the `self` param get's desuggared into a normal function parameter
    enum FnParsingMode { Method(Path), Function, }
    impl ::core::marker::StructuralPartialEq for FnParsingMode { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FnParsingMode {
        #[inline]
        fn eq(&self, other: &FnParsingMode) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&FnParsingMode::Method(ref __self_0),
                         &FnParsingMode::Method(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &FnParsingMode) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&FnParsingMode::Method(ref __self_0),
                         &FnParsingMode::Method(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for FnParsingMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&FnParsingMode::Method(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Method");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&FnParsingMode::Function,) => {
                    let mut debug_trait_builder = f.debug_tuple("Function");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    enum BlockParsingMode { Loop, Normal, }
    impl ::core::marker::StructuralPartialEq for BlockParsingMode { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for BlockParsingMode {
        #[inline]
        fn eq(&self, other: &BlockParsingMode) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BlockParsingMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&BlockParsingMode::Loop,) => {
                    let mut debug_trait_builder = f.debug_tuple("Loop");
                    debug_trait_builder.finish()
                }
                (&BlockParsingMode::Normal,) => {
                    let mut debug_trait_builder = f.debug_tuple("Normal");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for BlockParsingMode { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for BlockParsingMode {
        #[inline]
        fn clone(&self) -> BlockParsingMode { { *self } }
    }
    enum Directive { Expr, VarDef, Assign, }
    macro_rules! __bin_op_rule(($ name : ident, $ inner : ident, $ conv : ty,
                                $ kind : ident, $ ($ op_pattern : pat) | *) =>
                               (fn $ name(& mut self) -> ParseResult < Expr >
                                {
                                    let mut lhs = self . $ inner() ? ; while
                                    let Ok(tk) = self . peek_kind()
                                    {
                                        let op = match tk
                                        {
                                            $ ($ op_pattern) | * => self .
                                            advance() ?, _ => break,
                                        } ; let rhs = self . $ inner() ? ; let
                                        span = lhs . span .
                                        combine(& rhs . span) ; let op : $
                                        conv = op . try_into() ? ; lhs = Expr
                                        {
                                            node : ExprKind :: $ kind
                                            {
                                                lhs : Box :: new(lhs), rhs :
                                                Box :: new(rhs), op,
                                            }, ty : Ty
                                            {
                                                kind : TyKind :: Infer, span :
                                                span . clone(),
                                            }, span,
                                        } ;
                                    } Ok(lhs)
                                }) ;)
    macro_rules! logical_impl(($ name : ident, $ inner : ident, $
                               ($ op_pattern : pat) | *) =>
                              (__bin_op_rule !
                               ($ name, $ inner, CmpOp, Logical, $
                                ($ op_pattern) | *) ;) ;)
    macro_rules! binary_impl(($ name : ident, $ inner : ident, $
                              ($ op_pattern : pat) | *) =>
                             (__bin_op_rule !
                              ($ name, $ inner, BinaryOp, Binary, $
                               ($ op_pattern) | *) ;) ;)
    impl Parser {
        pub fn new(i: Vec<Token>) -> Self {
            let last = i.last().cloned();
            Parser{iter: multipeek(i.into_iter()), last,}
        }
        fn sync_parser_state(&mut self) {
            loop  {
                if let Ok(tk) = self.peek_kind() {
                    match tk {
                        TokenKind::EOF => { return; }
                        TokenKind::Keyword(Keyword::Struct) |
                        TokenKind::Keyword(Keyword::Fun) |
                        TokenKind::Keyword(Keyword::For) |
                        TokenKind::Keyword(Keyword::Impl) => return,
                        _ => self.advance().unwrap(),
                    };
                }
            }
        }
        pub fn parse(&mut self) -> ParseResult<Decl> { self.parse_decl() }
        pub fn parse_decl(&mut self) -> ParseResult<Decl> {
            match self.peek_kind()? {
                TokenKind::Keyword(Keyword::Fun) => {
                    Ok(Decl::Fn(self.parse_fn(FnParsingMode::Function)?))
                }
                TokenKind::Keyword(Keyword::Impl) => self.parse_impl(),
                TokenKind::Keyword(Keyword::Struct) =>
                Ok(Decl::TyDecl(self.parse_ty()?)),
                _ => {
                    let expected =
                        <[_]>::into_vec(box
                                            [TokenKind::Keyword(Keyword::Fun),
                                             TokenKind::Keyword(Keyword::Struct),
                                             TokenKind::Keyword(Keyword::Impl)]);
                    let t = self.advance()?;
                    let kind =
                        ErrKind::Syntax(SyntaxErr::MissingToken{expected,
                                                                actual:
                                                                    t.kind,});
                    Err(self.span_err(kind, t.span))
                }
            }
        }
        fn parse_ty(&mut self) -> ParseResult<TyDecl> {
            match self.look_ahead(3)? {
                TokenKind::LBrace => Ok(TyDecl::Struct(self.parse_struct()?)),
                TokenKind::Eq => Ok(TyDecl::Enum(self.parse_enum()?)),
                _ => {
                    let span = self.last.as_ref().unwrap().span;
                    let kind =
                        ErrKind::Syntax(SyntaxErr::MissingToken{expected:
                                                                    <[_]>::into_vec(box
                                                                                        [TokenKind::LBrace,
                                                                                         TokenKind::Eq]),
                                                                actual:
                                                                    self.look_ahead(3)?,});
                    return Err(self.span_err(kind, span));
                }
            }
        }
        fn parse_fn_header(&mut self, parse_mode: FnParsingMode)
         -> ParseResult<FnSig> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::Fun),
                            "An dieser Stelle haben wir das `fun` Schluesselwort erwartet!")?.span;
            let name = self.parse_ident()?;
            self.expect(TokenKind::LParen,
                        "An dieser Stelle haben wir eine ffnende Klammer `(` erwartet!")?;
            let mut params = Vec::new();
            match parse_mode {
                FnParsingMode::Method(p) => {
                    if self.peek_kind()? == TokenKind::Keyword(Keyword::This)
                       {
                        self.advance()?;
                        let sp = p.span;
                        let self_ty = Ty{kind: TyKind::Path(p), span: sp,};
                        params.push(Param::new(Ident::new("selbst".into(),
                                                          sp), self_ty, sp));
                        if self.peek_kind()? != TokenKind::RParen {
                            self.expect(TokenKind::Comma,
                                        "Nach dem `selbst` Parameter und den restlichen Parametern der Funktion haben wir ein Komma erwartet!")?;
                        }
                    }
                }
                FnParsingMode::Function => {
                    if self.peek_kind()? == TokenKind::Keyword(Keyword::This)
                       {
                        let sp = self.advance()?.span;
                        return Err(self.span_err(ErrKind::Syntax(SyntaxErr::SelfOutsideImpl),
                                                 sp));
                    }
                }
            }
            while self.peek_kind()? != TokenKind::RParen {
                let p_name = self.parse_ident()?;
                self.expect(TokenKind::Colon,
                            "Name und Typ eines Funktionsparameters werden durch einen `:` voneinander getrennt!")?;
                let p_ty = self.parse_ty_specifier()?;
                let sp = p_name.span.clone().combine(&p_ty.span.clone());
                params.push(Param::new(p_name.clone(), p_ty.clone(), sp));
                match self.peek_kind()? {
                    TokenKind::RParen => break ,
                    _ =>
                    self.expect(TokenKind::Comma,
                                "Die einzelnen Parameter einer Funktion werden durch ein Komma `,` voneinander getrennt!")?,
                };
            }
            let closing = self.expect(TokenKind::RParen, "Rueckgabetyp")?;
            let ret_ty =
                match self.peek_kind()? {
                    TokenKind::ThinArrow => {
                        self.advance()?;
                        self.parse_ty_specifier()?
                    }
                    _ => {
                        let sp =
                            Span::new(closing.span.lo + 4,
                                      closing.span.hi + 6);
                        Ty::default_unit_type(sp)
                    }
                };
            let span = ret_ty.span.combine(&start);
            Ok(FnSig{name, params, ret_ty, span,})
        }
        fn parse_fn(&mut self, parse_mode: FnParsingMode)
         -> ParseResult<FnDecl> {
            let header = self.parse_fn_header(parse_mode)?;
            let body = self.parse_block(BlockParsingMode::Normal)?;
            let span = header.span.combine(&body.span);
            Ok(FnDecl{header, body, span,})
        }
        fn parse_block(&mut self, mode: BlockParsingMode)
         -> ParseResult<Block> {
            let start =
                self.expect(TokenKind::LBrace,
                            "Geschweifte Klammer { vor Block erwartet")?.span;
            let mut block = Vec::new();
            while self.peek_kind()? != TokenKind::RBrace {
                block.push(self.parse_stmt(mode)?);
            }
            let end =
                self.expect(TokenKind::RBrace,
                            "Block nicht geschlossen?")?.span;
            Ok(Block::new(block, start.combine(&end)))
        }
        fn parse_stmt(&mut self, mode: BlockParsingMode)
         -> ParseResult<Stmt> {
            match self.peek_kind()? {
                TokenKind::Keyword(Keyword::While) => self.parse_while_loop(),
                TokenKind::Keyword(Keyword::For) => self.parse_for_loop(),
                TokenKind::Keyword(Keyword::Return) => self.parse_return(),
                TokenKind::Keyword(Keyword::Continue) =>
                self.parse_continue(mode),
                TokenKind::Keyword(Keyword::Break) => self.parse_break(mode),
                TokenKind::Keyword(Keyword::If) => self.parse_if(mode),
                TokenKind::LBrace => Ok(Stmt::Block(self.parse_block(mode)?)),
                _ =>
                match self.peek_directive()? {
                    Directive::VarDef => Ok(self.parse_vardef_stmt()?),
                    Directive::Assign => Ok(self.parse_assign()?),
                    Directive::Expr => Ok(self.parse_expr_stmt()?),
                },
            }
        }
        fn parse_while_loop(&mut self) -> ParseResult<Stmt> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::While),
                            "Solange")?.span;
            let cond = self.parse_expr()?;
            let body = self.parse_block(BlockParsingMode::Loop)?;
            let end = body.span;
            Ok(Stmt::While{cond, body, span: start.combine(&end),})
        }
        fn parse_for_loop(&mut self) -> ParseResult<Stmt> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::For), "Fuer")?.span;
            let vardef = self.parse_vardef()?;
            let body = self.parse_block(BlockParsingMode::Loop)?;
            let span = start.combine(&body.span);
            Ok(Stmt::For{vardef, body, span,})
        }
        fn parse_if(&mut self, mode: BlockParsingMode) -> ParseResult<Stmt> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::If),
                            "An dieser Stelle haben wir das `wenn` Schluesselwort erwartet. Mit `wenn` kann dein Programm Entscheidungen treffen. Der Programmtext innerhalb des Koerpers des `wenn` Befehls wird nur dann ausgefuehrt wenn sich seine Bedingung bewahrheitet!")?.span;
            let cond = self.parse_expr()?;
            self.expect(TokenKind::Keyword(Keyword::Then),
                        "Einem `wenn` muss auch ein `dann` folgen :D")?;
            let body = self.parse_block(mode)?;
            let mut else_branches = Vec::new();
            loop  {
                match (self.peek_kind()?, self.look_ahead(2)?) {
                    (TokenKind::Keyword(Keyword::Else),
                     TokenKind::Keyword(Keyword::If)) => {
                        else_branches.push(self.parse_elif_branch(mode)?)
                    }
                    _ => break ,
                }
            }
            let final_branch =
                if self.peek_kind()? == TokenKind::Keyword(Keyword::Else) {
                    let start = self.advance()?.span;
                    let body = self.parse_block(mode)?;
                    let sp = start.combine(&body.span.clone());
                    Some(FinalBranch{body, span: sp,})
                } else { None };
            let span =
                match final_branch {
                    Some(ref b) => start.combine(&b.span.clone()),
                    None => {
                        if !else_branches.is_empty() {
                            start.combine(&else_branches.last().unwrap().span)
                        } else { start.combine(&body.span.clone()) }
                    }
                };
            Ok(Stmt::If{cond, body, else_branches, final_branch, span,})
        }
        fn parse_elif_branch(&mut self, mode: BlockParsingMode)
         -> ParseResult<ElseBranch> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::Else),
                            "An dieser Stelle haben wir das `sonst` Schluesselwort erwartet! Es erlaubt dir nach einem primaeren `wenn` Befehl noch weitere Bedingung zu beachten.")?.span;
            self.expect(TokenKind::Keyword(Keyword::If),
                        "An dieser Stelle haben wir das `wenn` Schluesselwort erwartet! Es erlaubt dir feinere Entscheidungen nach einem `sonst` Befehl zu treffen")?;
            let cond = self.parse_expr()?;
            self.expect(TokenKind::Keyword(Keyword::Then),
                        "Wenn du eine 'Wenn-dann'-Abfrage machst, muss auf das 'Wenn' immer ein 'dann' folgen, so wissen wir, was wir machen mssen wenn das 'wenn'-statement erfllt ist,Einem `wenn` muss auch ein `dann` folgen!")?;
            let body = self.parse_block(mode)?;
            let span = start.combine(&body.span.clone());
            Ok(ElseBranch{cond, body, span,})
        }
        fn parse_return(&mut self) -> ParseResult<Stmt> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::Return),
                            "Wenn du etwas zuruckgeben willst musst du das Wort 'Rckgabe' benutzen, es zeigt uns was du zurckgeben willst! Das was du zurckgeben willst muss immer hinter 'Rckgabe'stehen. Als letztes kommt immer ein Semikolon(;)! Rueckgabe schluesselwort")?.span;
            let ret_val =
                match self.peek_kind()? {
                    TokenKind::Semi => Expr::empty(start),
                    _ => self.parse_expr()?,
                };
            let end =
                self.expect(TokenKind::Semi,
                            "Wenn du etwas zurckgeben willst musst du immer ein Semikolon `;` dahinter schreiben!(; nach rueckgabe erwartet)")?.span;
            Ok(Stmt::Ret(ret_val, start.combine(&end)))
        }
        fn peek_directive(&mut self) -> ParseResult<Directive> {
            let mut i = 1;
            loop  {
                match self.look_ahead(i)? {
                    TokenKind::Colon | TokenKind::ColonEq =>
                    return Ok(Directive::VarDef),
                    TokenKind::Eq => return Ok(Directive::Assign),
                    TokenKind::Semi => return Ok(Directive::Expr),
                    TokenKind::EOF => {
                        let sp = self.last.as_ref().unwrap().span;
                        return Err(self.span_err(ErrKind::Syntax(SyntaxErr::UnexpectedEOF),
                                                 sp));
                    }
                    _ => i += 1,
                }
            }
        }
        fn parse_vardef(&mut self) -> ParseResult<VarDef> {
            let pat = self.parse_ident()?;
            let ty =
                match self.peek_kind()? {
                    TokenKind::ColonEq => {
                        let span = self.advance()?.span;
                        Ty{kind: TyKind::Infer, span,}
                    }
                    TokenKind::Colon => {
                        self.advance()?;
                        self.parse_ty_specifier()?
                    }
                    _ => {
                        let pk = self.advance()?;
                        return Err(self.span_err(ErrKind::Syntax(SyntaxErr::InvalidVarDefTarget),
                                                 pk.span));
                    }
                };
            let init = self.parse_expr()?;
            let span = pat.span.combine(&init.span);
            Ok(VarDef{pat, init, ty, span,})
        }
        fn parse_vardef_stmt(&mut self) -> ParseResult<Stmt> {
            let vardef = self.parse_vardef()?;
            self.expect(TokenKind::Semi,
                        "Wenn du eine Variable definieren willst musst du immer ein Semikolon(;) schreiben, wir wissen dann, wann die definition aufhrt., Nach einer Variablendefinition haben wir ein Semicolon erwartet!")?;
            Ok(Stmt::VarDef(vardef))
        }
        fn parse_assign(&mut self) -> ParseResult<Stmt> {
            let lhs = self.parse_expr()?;
            self.expect(TokenKind::Eq, "Gleichheitszeichen")?;
            let rhs = self.parse_expr()?;
            let span = lhs.span.combine(&rhs.span);
            self.expect(TokenKind::Semi, "Semicolon")?;
            match lhs.node {
                ExprKind::Path(..) | ExprKind::Field(..) | ExprKind::Index {
                .. } | ExprKind::This => {
                    Ok(Stmt::Assign{lhs, rhs, span,})
                }
                _ =>
                Err(self.span_err(ErrKind::Syntax(SyntaxErr::InvalidAssignmentTarget),
                                  lhs.span)),
            }
        }
        fn parse_expr_stmt(&mut self) -> ParseResult<Stmt> {
            let expr = self.parse_expr()?;
            self.expect(TokenKind::Semi,
                        "Semicolon nach Ausdruck vergessen")?;
            Ok(Stmt::Expr(expr))
        }
        fn parse_break(&mut self, mode: BlockParsingMode)
         -> ParseResult<Stmt> {
            if mode == BlockParsingMode::Normal {
                let span = self.advance()?.span;
                return Err(self.span_err(ErrKind::Syntax(SyntaxErr::BreakOutsideLoop),
                                         span));
            }
            let start =
                self.expect(TokenKind::Keyword(Keyword::Break),
                            "Stop befehl")?.span;
            let end = self.expect(TokenKind::Semi, "Stop")?.span;
            Ok(Stmt::Break(start.combine(&end)))
        }
        fn parse_continue(&mut self, mode: BlockParsingMode)
         -> ParseResult<Stmt> {
            if mode == BlockParsingMode::Normal {
                let span = self.advance()?.span;
                return Err(self.span_err(ErrKind::Syntax(SyntaxErr::BreakOutsideLoop),
                                         span));
            }
            let start =
                self.expect(TokenKind::Keyword(Keyword::Continue),
                            "weiter befehl")?.span;
            let end = self.expect(TokenKind::Semi, "weiter")?.span;
            Ok(Stmt::Continue(start.combine(&end)))
        }
        fn parse_impl(&mut self) -> ParseResult<Decl> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::Impl),
                            "Hier haben wir eine Implementierung erwartet. Schau was hier Implementiert wird, und Implementiere da dann.An dieser Stelle haben wir das Impl Schluesselwort erwartet!")?.span;
            let impl_target = self.parse_path()?;
            self.expect(TokenKind::LBrace,
                        "Wir denken, dass du an dieser Stelle vergessen hast eine ffnende geschweifte Klamer { zu schreiben. An dieser Stelle haben wir eine oeffnende Klammer: `{` erwartet")?;
            let mut fn_decls = Vec::new();
            loop  {
                match self.peek_kind()? {
                    TokenKind::RBrace => break ,
                    TokenKind::Keyword(Keyword::Fun) => {
                        let mode = FnParsingMode::Method(impl_target.clone());
                        fn_decls.push(self.parse_fn(mode)?);
                    }
                    _ => {
                        let sp = self.last.as_ref().unwrap().span;
                        let expected =
                            <[_]>::into_vec(box
                                                [TokenKind::Keyword(Keyword::Fun),
                                                 TokenKind::RBrace]);
                        let err =
                            ErrKind::Syntax(SyntaxErr::MissingToken{expected,
                                                                    actual:
                                                                        self.peek_kind()?,});
                        return Err(self.span_err(err, sp));
                    }
                }
            }
            let end =
                self.expect(TokenKind::RBrace,
                            "Wir denken, dass du an dieser Stelle vergessen hast eine schlieende geschweifte Klamer } zu schreiben. Wir denken An dieser Stelle haben wir eine schliessende Klammer: `}` erwartet")?.span;
            Ok(Decl::Impl{target: impl_target,
                          fn_decls,
                          span: start.combine(&end),})
        }
        fn parse_struct(&mut self) -> ParseResult<Struct> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::Struct),
                            "TypenDeclaration")?.span;
            let name = self.parse_ident()?;
            let mut fields = Vec::new();
            self.expect(TokenKind::LBrace, "Typenname")?;
            while self.peek_kind()? != TokenKind::RBrace {
                let name = self.parse_ident()?;
                self.expect(TokenKind::Colon, "feldname")?;
                let ty = self.parse_ty_specifier()?;
                let span = name.span.combine(&ty.span);
                fields.push(Field::new(name, ty, span));
                match self.peek_kind()? {
                    TokenKind::RBrace => break ,
                    _ => self.expect(TokenKind::Comma, "feld")?,
                };
            }
            let end =
                self.expect(TokenKind::RBrace, "TypenDeclaration")?.span;
            Ok(Struct{name,
                      fields,
                      methods: Vec::new(),
                      span: start.combine(&end),})
        }
        fn parse_enum(&mut self) -> ParseResult<Enum> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::Struct),
                            "enum or struct declaration")?.span;
            let name = self.parse_ident()?;
            self.expect(TokenKind::Eq, "EnumDecl")?;
            let mut variants = Vec::new();
            loop  {
                match self.peek_kind()? {
                    TokenKind::Sep => {
                        self.advance()?;
                        variants.push(self.parse_enum_variant()?)
                    }
                    TokenKind::Ident(_) =>
                    variants.push(self.parse_enum_variant()?),
                    _ => break ,
                };
            }
            let end =
                match variants.last() {
                    Some(v) => v.span,
                    None => name.span,
                };
            Ok(Enum{name,
                    variants,
                    methods: Vec::new(),
                    span: start.combine(&end),})
        }
        fn parse_enum_variant(&mut self) -> ParseResult<Variant> {
            let name = self.parse_ident()?;
            let (data, end) =
                match self.peek_kind()? {
                    TokenKind::LParen => {
                        self.advance()?;
                        let mut elems = Vec::new();
                        loop  {
                            match self.peek_kind()? {
                                TokenKind::RParen => break ,
                                _ => elems.push(self.parse_ty_specifier()?),
                            };
                        }
                        let end =
                            self.expect(TokenKind::RParen, "enum arm")?.span;
                        (VariantData::Val(elems), end)
                    }
                    _ => (VariantData::Unit, name.span),
                };
            Ok(Variant{span: name.span.combine(&end), ident: name, data,})
        }
        fn parse_ty_kind(&mut self) -> ParseResult<TyKind> {
            match self.peek_kind()? {
                TokenKind::LBracket => {
                    self.advance()?;
                    let ty = self.parse_ty_specifier()?;
                    self.expect(TokenKind::RBracket, "Feldelementtyp")?;
                    Ok(TyKind::Array(Box::new(ty)))
                }
                TokenKind::LParen => {
                    self.advance()?;
                    let mut elems = Vec::new();
                    while self.peek_kind()? != TokenKind::RParen {
                        let ty = self.parse_ty_specifier()?;
                        elems.push(ty);
                        match self.peek_kind()? {
                            TokenKind::RParen => break ,
                            _ =>
                            self.expect(TokenKind::Comma, "Tupleelement")?,
                        };
                    }
                    self.expect(TokenKind::RParen, "Tuple")?;
                    Ok(TyKind::Tup(elems))
                }
                TokenKind::Ident(_) => {
                    let p = self.parse_path()?;
                    Ok(TyKind::Path(p))
                }
                TokenKind::Dollar => {
                    self.advance()?;
                    let name = self.parse_ident()?;
                    Ok(TyKind::Poly(name))
                }
                _ => {
                    let sp = self.advance()?.span;
                    Err(self.span_err(ErrKind::Syntax(SyntaxErr::ExpectedTy),
                                      sp))
                }
            }
        }
        fn parse_ty_specifier(&mut self) -> ParseResult<Ty> {
            let start = self.last.as_ref().unwrap().span;
            let kind = self.parse_ty_kind()?;
            let end = self.last.as_ref().unwrap().span;
            Ok(Ty{kind, span: start.combine(&end),})
        }
        fn parse_path(&mut self) -> ParseResult<Path> {
            let mut segments = Vec::new();
            while let TokenKind::Ident(_) = self.peek_kind()? {
                let frag = self.parse_ident()?;
                segments.push(frag);
                match self.peek_kind()? {
                    TokenKind::PathSep => { self.advance()?; }
                    _ => break ,
                };
            }
            let first = segments.first().unwrap().span;
            let last = segments.last().unwrap().span;
            Ok(Path::new(segments, first.combine(&last)))
        }
        fn parse_or(&mut self) -> ParseResult<Expr> {
            let mut lhs = self.parse_and()?;
            while let Ok(tk) = self.peek_kind() {
                let op =
                    match tk {
                        TokenKind::Operator(Operator::Or) => self.advance()?,
                        _ => break ,
                    };
                let rhs = self.parse_and()?;
                let span = lhs.span.combine(&rhs.span);
                let op: CmpOp = op.try_into()?;
                lhs =
                    Expr{node:
                             ExprKind::Logical{lhs: Box::new(lhs),
                                               rhs: Box::new(rhs),
                                               op,},
                         ty: Ty{kind: TyKind::Infer, span: span.clone(),},
                         span,};
            }
            Ok(lhs)
        }
        fn parse_and(&mut self) -> ParseResult<Expr> {
            let mut lhs = self.parse_eq()?;
            while let Ok(tk) = self.peek_kind() {
                let op =
                    match tk {
                        TokenKind::Operator(Operator::And) => self.advance()?,
                        _ => break ,
                    };
                let rhs = self.parse_eq()?;
                let span = lhs.span.combine(&rhs.span);
                let op: CmpOp = op.try_into()?;
                lhs =
                    Expr{node:
                             ExprKind::Logical{lhs: Box::new(lhs),
                                               rhs: Box::new(rhs),
                                               op,},
                         ty: Ty{kind: TyKind::Infer, span: span.clone(),},
                         span,};
            }
            Ok(lhs)
        }
        fn parse_eq(&mut self) -> ParseResult<Expr> {
            let mut lhs = self.parse_cmp()?;
            while let Ok(tk) = self.peek_kind() {
                let op =
                    match tk {
                        TokenKind::Operator(Operator::EqEq) |
                        TokenKind::Operator(Operator::NotEq) =>
                        self.advance()?,
                        _ => break ,
                    };
                let rhs = self.parse_cmp()?;
                let span = lhs.span.combine(&rhs.span);
                let op: CmpOp = op.try_into()?;
                lhs =
                    Expr{node:
                             ExprKind::Logical{lhs: Box::new(lhs),
                                               rhs: Box::new(rhs),
                                               op,},
                         ty: Ty{kind: TyKind::Infer, span: span.clone(),},
                         span,};
            }
            Ok(lhs)
        }
        fn parse_cmp(&mut self) -> ParseResult<Expr> {
            let mut lhs = self.parse_term()?;
            while let Ok(tk) = self.peek_kind() {
                let op =
                    match tk {
                        TokenKind::Operator(Operator::Greater) |
                        TokenKind::Operator(Operator::GreaterEq) |
                        TokenKind::Operator(Operator::Less) |
                        TokenKind::Operator(Operator::LessEq) =>
                        self.advance()?,
                        _ => break ,
                    };
                let rhs = self.parse_term()?;
                let span = lhs.span.combine(&rhs.span);
                let op: CmpOp = op.try_into()?;
                lhs =
                    Expr{node:
                             ExprKind::Logical{lhs: Box::new(lhs),
                                               rhs: Box::new(rhs),
                                               op,},
                         ty: Ty{kind: TyKind::Infer, span: span.clone(),},
                         span,};
            }
            Ok(lhs)
        }
        fn parse_term(&mut self) -> ParseResult<Expr> {
            let mut lhs = self.parse_factor()?;
            while let Ok(tk) = self.peek_kind() {
                let op =
                    match tk {
                        TokenKind::Operator(Operator::Plus) |
                        TokenKind::Operator(Operator::Minus) =>
                        self.advance()?,
                        _ => break ,
                    };
                let rhs = self.parse_factor()?;
                let span = lhs.span.combine(&rhs.span);
                let op: BinaryOp = op.try_into()?;
                lhs =
                    Expr{node:
                             ExprKind::Binary{lhs: Box::new(lhs),
                                              rhs: Box::new(rhs),
                                              op,},
                         ty: Ty{kind: TyKind::Infer, span: span.clone(),},
                         span,};
            }
            Ok(lhs)
        }
        fn parse_factor(&mut self) -> ParseResult<Expr> {
            let mut lhs = self.parse_unary()?;
            while let Ok(tk) = self.peek_kind() {
                let op =
                    match tk {
                        TokenKind::Operator(Operator::Slash) |
                        TokenKind::Operator(Operator::Star) =>
                        self.advance()?,
                        _ => break ,
                    };
                let rhs = self.parse_unary()?;
                let span = lhs.span.combine(&rhs.span);
                let op: BinaryOp = op.try_into()?;
                lhs =
                    Expr{node:
                             ExprKind::Binary{lhs: Box::new(lhs),
                                              rhs: Box::new(rhs),
                                              op,},
                         ty: Ty{kind: TyKind::Infer, span: span.clone(),},
                         span,};
            }
            Ok(lhs)
        }
        fn parse_expr(&mut self) -> ParseResult<Expr> { self.parse_range() }
        fn parse_range(&mut self) -> ParseResult<Expr> {
            let lhs = self.parse_or()?;
            if self.peek_kind()? == TokenKind::Operator(Operator::Range) {
                self.advance()?;
                let rhs = self.parse_or()?;
                let span = lhs.span.combine(&rhs.span);
                return Ok(Expr{node:
                                   ExprKind::Range(Box::new(lhs),
                                                   Box::new(rhs)),
                               span,
                               ty: Ty{kind: TyKind::Infer, span,},});
            }
            Ok(lhs)
        }
        fn parse_unary(&mut self) -> ParseResult<Expr> {
            match self.peek_kind()? {
                TokenKind::Operator(Operator::Not) |
                TokenKind::Operator(Operator::Minus) => {
                    let op = self.advance()?;
                    let rhs = self.parse_unary()?;
                    let span = op.span.combine(&rhs.span);
                    Ok(Expr{node:
                                ExprKind::Unary{rhs: Box::new(rhs),
                                                op: op.try_into()?,},
                            span,
                            ty: Ty{kind: TyKind::Infer, span,},})
                }
                TokenKind::Keyword(Keyword::Print) |
                TokenKind::Keyword(Keyword::Read) |
                TokenKind::Keyword(Keyword::Write) => self.parse_intrinsic(),
                _ => self.parse_call(),
            }
        }
        fn parse_intrinsic(&mut self) -> ParseResult<Expr> {
            match self.peek_kind()? {
                TokenKind::Keyword(Keyword::Print) => self.parse_print(),
                TokenKind::Keyword(Keyword::Read) => self.parse_read(),
                TokenKind::Keyword(Keyword::Write) => self.parse_print(),
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code")
                    }
                }
            }
        }
        fn parse_print(&mut self) -> ParseResult<Expr> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::Print),
                            "Ausgabe schluesselwort")?.span;
            self.expect(TokenKind::LParen,
                        "Kompiler intrinsiche Funktionen werden wie normale Funktionen aufgerufen!")?;
            let mut args = Vec::new();
            args.push(self.parse_expr()?);
            loop  {
                match self.peek_kind()? {
                    TokenKind::RParen => break ,
                    _ => {
                        self.expect(TokenKind::Comma,
                                    "Auch bei intrinsichen Funktionen werden Argumente mit einem Komma getrennt!")?;
                        args.push(self.parse_expr()?);
                    }
                }
            }
            let end =
                self.expect(TokenKind::RParen,
                            "Es scheint als haettest du eine schliessende Klammer fuer den #ausgabe befehl vergessen")?.span;
            let span = start.combine(&end);
            Ok(Expr{node: ExprKind::Intrinsic{kind: Intrinsic::Print, args,},
                    span,
                    ty: Ty{kind: TyKind::Infer, span,},})
        }
        fn parse_read(&mut self) -> ParseResult<Expr> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::Read),
                            "An dieser stelle haben wir den intrinsichen Lese Befehl erwartet!")?.span;
            self.expect(TokenKind::LParen,
                        "Kompiler intrinsiche Funktionen werden wie normale Funktionen aufgerufen!")?;
            let file_name = self.parse_expr()?;
            let end =
                self.expect(TokenKind::RParen,
                            "Kompiler intrinsiche Funktionen werden wie normale Funktionen aufgerufen!")?.span;
            let span = start.combine(&end);
            Ok(Expr{node:
                        ExprKind::Intrinsic{kind: Intrinsic::Read,
                                            args:
                                                <[_]>::into_vec(box
                                                                    [file_name]),},
                    span,
                    ty: Ty{kind: TyKind::Infer, span,},})
        }
        fn parse_write(&mut self) -> ParseResult<Expr> {
            let start =
                self.expect(TokenKind::Keyword(Keyword::Read),
                            "An dieser stelle haben wir den intrinsichen Lese Befehl erwartet!")?.span;
            self.expect(TokenKind::LParen,
                        "Kompiler intrinsiche Funktionen werden wie normale Funktionen aufgerufen!")?;
            let file_name = self.parse_expr()?;
            self.expect(TokenKind::Comma,
                        "Auch die Argumente einer intrinsichen Funktion werden mit einem Komma getrennt")?;
            let content = self.parse_expr()?;
            let end =
                self.expect(TokenKind::RParen,
                            "Kompiler intrinsiche Funktionen werden wie normale Funktionen aufgerufen!")?.span;
            let span = start.combine(&end);
            Ok(Expr{node:
                        ExprKind::Intrinsic{kind: Intrinsic::Write,
                                            args:
                                                <[_]>::into_vec(box
                                                                    [file_name,
                                                                     content]),},
                    span,
                    ty: Ty{kind: TyKind::Infer, span,},})
        }
        fn parse_struct_lit(&mut self, name: Ident) -> ParseResult<Expr> {
            self.expect(TokenKind::LBrace,
                        "Offene Klammer nach typenliteral")?;
            let mut members = Vec::new();
            while self.peek_kind()? != TokenKind::RBrace {
                let name = self.parse_ident()?;
                self.expect(TokenKind::Colon,
                            ": Seperator zwischen feldname und init Ausdruck")?;
                let expr = self.parse_expr()?;
                let span = name.span.combine(&expr.span);
                let member = Member::new(name, expr, span);
                members.push(member);
                match self.peek_kind()? {
                    TokenKind::RBrace => break ,
                    _ => self.expect(TokenKind::Comma, "literalfeld")?,
                };
            }
            let end =
                self.expect(TokenKind::RBrace,
                            "Wir denken du hast hier eine schlieende Klammer `(` vergessen. schlissende Klammer vergessen?")?.span;
            let span = name.span.combine(&end);
            let expr =
                Expr{node: ExprKind::Struct{name, members,},
                     span,
                     ty: Ty{kind: TyKind::Infer, span,},};
            Ok(expr)
        }
        fn parse_primary(&mut self) -> ParseResult<Expr> {
            match self.peek_kind()? {
                TokenKind::Keyword(Keyword::This) => {
                    let sp = self.advance()?.span;
                    let node = ExprKind::This;
                    Ok(Expr::new(node, sp))
                }
                TokenKind::Lit(lit) => {
                    let span = self.advance()?.span;
                    Ok(Expr{node: ExprKind::Lit(lit),
                            ty: Ty{kind: TyKind::Infer, span,},
                            span,})
                }
                TokenKind::LParen => self.parse_tup(),
                TokenKind::LBracket => self.parse_arr(),
                TokenKind::Ident(_) => self.parse_primary_ident(),
                _ => {
                    let sp = self.advance()?.span;
                    Err(self.span_err(ErrKind::Syntax(SyntaxErr::ExpectedExpr),
                                      sp))
                }
            }
        }
        fn parse_primary_ident(&mut self) -> ParseResult<Expr> {
            let pat = self.parse_path()?;
            match self.peek_kind()? {
                TokenKind::LBrace =>
                match pat.len() {
                    1 => self.parse_struct_lit(pat.first().unwrap().clone()),
                    _ => {
                        let expected =
                            <[_]>::into_vec(box
                                                [TokenKind::LBrace,
                                                 TokenKind::PathSep]);
                        let err =
                            ErrKind::Syntax(SyntaxErr::MissingToken{expected,
                                                                    actual:
                                                                        self.peek_kind()?,});
                        let span = self.advance()?.span;
                        Err(self.span_err(err, span))
                    }
                },
                _ => {
                    let span = pat.span;
                    Ok(Expr{node: ExprKind::Path(pat),
                            span,
                            ty: Ty{kind: TyKind::Infer, span,},})
                }
            }
        }
        fn parse_tup(&mut self) -> ParseResult<Expr> {
            let start = self.advance()?.span;
            let mut values = Vec::new();
            while self.peek_kind()? != TokenKind::RParen {
                values.push(self.parse_expr()?);
                match self.peek_kind()? {
                    TokenKind::RParen => break ,
                    _ => self.expect(TokenKind::Comma, "ausdruck")?,
                };
            }
            let end =
                self.expect(TokenKind::RParen, "schliessende Klammer")?.span;
            let span = start.combine(&end);
            Ok(Expr{node: ExprKind::Tup(values),
                    span,
                    ty: Ty{kind: TyKind::Infer, span,},})
        }
        fn parse_arr(&mut self) -> ParseResult<Expr> {
            let start = self.expect(TokenKind::LBracket, "Feldliteral")?.span;
            let mut values = Vec::new();
            while self.peek_kind()? != TokenKind::RBracket {
                values.push(self.parse_expr()?);
                match self.peek_kind()? {
                    TokenKind::RBracket => break ,
                    _ => self.expect(TokenKind::Comma, "Feldelement")?,
                };
            }
            let end = self.expect(TokenKind::RBracket, "Feldliteral")?.span;
            let span = start.combine(&end);
            Ok(Expr{node: ExprKind::Array(values),
                    span: start.combine(&end),
                    ty: Ty{kind: TyKind::Infer, span,},})
        }
        fn parse_call(&mut self) -> ParseResult<Expr> {
            let mut expr = self.parse_primary()?;
            loop  {
                match self.peek_kind()? {
                    TokenKind::LParen => {
                        self.advance()?;
                        expr = self.finish_call(expr)?;
                    }
                    TokenKind::LBracket => { expr = self.parse_index(expr)?; }
                    TokenKind::Dot => {
                        let start = self.advance()?.span;
                        let name = self.parse_ident()?;
                        let span = start.combine(&name.span);
                        let node = ExprKind::Field(Box::new(expr), name);
                        expr = Expr::new(node, span)
                    }
                    _ => break ,
                }
            }
            Ok(expr)
        }
        fn finish_call(&mut self, callee: Expr) -> ParseResult<Expr> {
            let mut args = Vec::new();
            while self.peek_kind()? != TokenKind::RParen {
                args.push(self.parse_expr()?);
                if self.peek_kind()? == TokenKind::RParen {
                    break ;
                } else { self.expect(TokenKind::Comma, "Argument")?; }
            }
            let end = self.expect(TokenKind::RParen, "argumente")?.span;
            let span = callee.span.combine(&end);
            Ok(Expr{span,
                    node: ExprKind::Call{callee: Box::new(callee), args,},
                    ty: Ty{kind: TyKind::Infer, span,},})
        }
        fn parse_index(&mut self, callee: Expr) -> ParseResult<Expr> {
            let start =
                self.expect(TokenKind::LBracket,
                            "Wenn du ein Feld erstellten willst, musst du [ benutzen. Hier ist [ der Feldindex! Feldindex")?.span;
            let index = self.parse_expr()?;
            let end =
                self.expect(TokenKind::RBracket,
                            "Wenn du ein Feld erstellen willst, musst du ] benutzen. Hier ist ] der Feldindex! ] nach Feldindex")?.span;
            let span = start.combine(&end);
            Ok(Expr{node:
                        ExprKind::Index{callee: Box::new(callee),
                                        index: Box::new(index),},
                    span,
                    ty: Ty{kind: TyKind::Infer, span,},})
        }
        fn parse_ident(&mut self) -> ParseResult<Ident> {
            match self.peek_kind()? {
                TokenKind::Ident(_) => self.advance()?.try_into(),
                _ => {
                    let sp = self.advance()?.span;
                    let err = ErrKind::Syntax(SyntaxErr::ExpectedTy);
                    Err(self.span_err(err, sp))
                }
            }
        }
        fn peek_kind(&mut self) -> ParseResult<TokenKind> {
            let item =
                match self.iter.peek() {
                    Some(t) => Ok(t.kind.clone()),
                    None => Ok(TokenKind::EOF),
                };
            self.iter.reset_peek();
            item
        }
        fn look_ahead(&mut self, i: u8) -> ParseResult<TokenKind> {
            if true {
                if !(i > 0) {
                    { ::std::rt::begin_panic("Can't peek into the void!") }
                };
            };
            for _ in 0..i - 1 { self.iter.peek(); }
            let item =
                match self.iter.peek() {
                    Some(t) => Ok(t.kind.clone()),
                    None => Ok(TokenKind::EOF),
                };
            self.iter.reset_peek();
            item
        }
        fn advance(&mut self) -> ParseResult<Token> {
            match self.iter.next() {
                Some(t) => { self.last = Some(t.clone()); Ok(t) }
                None =>
                Err(self.span_err(ErrKind::Syntax(SyntaxErr::UnexpectedEOF),
                                  self.last.as_ref().unwrap().span)),
            }
        }
        fn has_next(&mut self) -> bool {
            let res = self.iter.peek().is_some();
            self.iter.reset_peek();
            res
        }
        fn expect(&mut self, expected: TokenKind, s: &str)
         -> ParseResult<Token> {
            if self.peek_kind()? == expected {
                self.advance()
            } else {
                let span = self.last.as_ref().unwrap().span;
                let diag =
                    Diagnostic{kind:
                                   ErrKind::Syntax(SyntaxErr::MissingToken{expected:
                                                                               <[_]>::into_vec(box
                                                                                                   [expected]),
                                                                           actual:
                                                                               self.peek_kind()?,}),
                               suggestions:
                                   <[_]>::into_vec(box [s.to_string()]),
                               span,};
                Err(diag)
            }
        }
        fn span_err(&self, kind: ErrKind, span: Span) -> Diagnostic {
            Diagnostic{kind, suggestions: Vec::new(), span,}
        }
    }
    impl Iterator for Parser {
        type Item = ParseResult<Decl>;
        fn next(&mut self) -> Option<Self::Item> {
            if self.has_next() {
                match self.parse() {
                    Ok(decl) => Some(Ok(decl)),
                    Err(err) => { self.sync_parser_state(); Some(Err(err)) }
                }
            } else { None }
        }
    }
}
mod session {
    use std::path::PathBuf;
    use std::time::Instant;
    use crate::typer::*;
    use crate::ast::*;
    use crate::errors::*;
    use crate::interp::*;
    use crate::lexer::*;
    use crate::lowering::*;
    use crate::parser::*;
    pub struct SourceMap {
        pub path: PathBuf,
        pub buf: String,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for SourceMap {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                SourceMap { path: ref __self_0_0, buf: ref __self_0_1 } => {
                    let mut debug_trait_builder = f.debug_struct("SourceMap");
                    let _ =
                        debug_trait_builder.field("path", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("buf", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SourceMap {
        #[inline]
        fn clone(&self) -> SourceMap {
            match *self {
                SourceMap { path: ref __self_0_0, buf: ref __self_0_1 } =>
                SourceMap{path: ::core::clone::Clone::clone(&(*__self_0_0)),
                          buf: ::core::clone::Clone::clone(&(*__self_0_1)),},
            }
        }
    }
    pub struct Driver {
        pub sess: Session,
    }
    impl Driver {
        pub fn new(files: Vec<PathBuf>) -> Self {
            Self{sess: Session::new(files),}
        }
        pub fn compile(&mut self) {
            let current_src_map =
                self.sess.files.get(self.sess.current).unwrap();
            let now = Instant::now();
            let buf = &self.sess.files.first().unwrap().buf;
            let t_stream =
                Lexer::new(&buf).collect::<Result<Vec<Token>,
                                                  Diagnostic>>().expect("failed to tokenize file");
            let t_stream = infer_semis(t_stream);
            let ast =
                Parser::new(t_stream).collect::<Vec<Result<Decl,
                                                           Diagnostic>>>();
            {
                ::std::io::_print(::core::fmt::Arguments::new_v1_formatted(&["",
                                                                             "\n"],
                                                                           &match (&now.elapsed(),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Debug::fmt)],
                                                                            },
                                                                           &[::core::fmt::rt::v1::Argument{position:
                                                                                                               0usize,
                                                                                                           format:
                                                                                                               ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                   ' ',
                                                                                                                                               align:
                                                                                                                                                   ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                               flags:
                                                                                                                                                   4u32,
                                                                                                                                               precision:
                                                                                                                                                   ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                               width:
                                                                                                                                                   ::core::fmt::rt::v1::Count::Implied,},}]));
            };
            let (ast, errors): (Vec<_>, Vec<_>) =
                ast.into_iter().partition(Result::is_ok);
            let mut ast: Vec<_> =
                ast.into_iter().map(Result::unwrap).collect();
            reorder(&mut ast);
            errors.into_iter().map(Result::unwrap_err).map(|diag|
                                                               UserDiagnostic::new(diag,
                                                                                   current_src_map.clone())).for_each(|diag|
                                                                                                                          {
                                                                                                                              ::std::io::_print(::core::fmt::Arguments::new_v1(&["",
                                                                                                                                                                                 "\n"],
                                                                                                                                                                               &match (&diag,)
                                                                                                                                                                                    {
                                                                                                                                                                                    (arg0,)
                                                                                                                                                                                    =>
                                                                                                                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                                                                                                                }));
                                                                                                                          });
            Typer::new().infer_types(&mut ast);
            Interp::new().interp(&mut ast);
            let had_err =
                self.sess.diagnostics.iter().any(|d|
                                                     match d.kind {
                                                         ErrKind::Runtime(_) |
                                                         ErrKind::Syntax(_) |
                                                         ErrKind::Type(_) |
                                                         ErrKind::Internal(_)
                                                         => {
                                                             true
                                                         }
                                                         ErrKind::Warning { ..
                                                         } => false,
                                                     });
            if had_err {
                {
                    ::std::io::_eprint(::core::fmt::Arguments::new_v1(&["Fehler beim Kompilieren gefunden. Programm wird nicht ausgefuehrt! :c\n\n"],
                                                                      &match ()
                                                                           {
                                                                           ()
                                                                           =>
                                                                           [],
                                                                       }));
                };
            }
        }
    }
    impl SourceMap {
        pub fn new(path: PathBuf) -> Self {
            let buf =
                std::fs::read_to_string(&path).expect("failed to read file");
            Self{path, buf,}
        }
    }
    pub struct Session {
        pub files: Vec<SourceMap>,
        pub diagnostics: Vec<Diagnostic>,
        pub current: usize,
    }
    impl Session {
        pub fn new(files: Vec<PathBuf>) -> Self {
            Self{files: files.into_iter().map(SourceMap::new).collect(),
                 current: 0,
                 diagnostics: Vec::new(),}
        }
    }
}
mod typer {
    use crate::cxt::Cxt;
    use std::collections::*;
    use std::convert::TryFrom;
    use std::fmt;
    use crate::errors::*;
    use crate::lexer::*;
    use derivative::*;
    use itertools::Itertools;
    use crate::ast::*;
    use crate::errors::Diagnostic;
    #[allow(dead_code)]
    const WORD_CMP_TRESHOLD: f32 = 0.2;
    #[derivative(Debug, PartialEq, Clone)]
    pub struct Ty {
        pub kind: TyKind,
        #[derivative(Debug = "ignore")]
        pub span: Span,
    }
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Ty {
        fn clone(&self) -> Self {
            match *self {
                Ty { kind: ref __arg_0, span: ref __arg_1 } => {
                    Ty{kind: __arg_0.clone(), span: __arg_1.clone(),}
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Ty {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Ty { kind: ref __arg_0, span: ref __arg_1 } => {
                    let mut __debug_trait_builder = __f.debug_struct("Ty");
                    let _ = __debug_trait_builder.field("kind", &__arg_0);
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Ty {
        fn eq(&self, other: &Self) -> bool {
            true &&
                match (&*self, &*other) {
                    (Ty { kind: ref __self_0, span: ref __self_1 }, Ty {
                     kind: ref __other_0, span: ref __other_1 }) => {
                        true && __self_0 == __other_0 && __self_1 == __other_1
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    impl Ty {
        pub fn infer_internal(&mut self) {
            self.kind = self.kind.infer_internal_types();
        }
        pub fn default_unit_type(span: Span) -> Self {
            Ty{kind: TyKind::Tup(Vec::new()), span,}
        }
        pub fn is_unit(&self) -> bool {
            match &self.kind {
                TyKind::Tup(t) if t.is_empty() => true,
                _ => false,
            }
        }
    }
    enum Constraint { Eq(TyKind, TyKind), }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Constraint {
        #[inline]
        fn clone(&self) -> Constraint {
            match (&*self,) {
                (&Constraint::Eq(ref __self_0, ref __self_1),) =>
                Constraint::Eq(::core::clone::Clone::clone(&(*__self_0)),
                               ::core::clone::Clone::clone(&(*__self_1))),
            }
        }
    }
    impl fmt::Debug for Constraint {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Constraint::Eq(lhs, rhs) =>
                f.write_fmt(::core::fmt::Arguments::new_v1(&["", " == "],
                                                           &match (&lhs.to_str(),
                                                                   &rhs.to_str())
                                                                {
                                                                (arg0, arg1)
                                                                =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt),
                                                                 ::core::fmt::ArgumentV1::new(arg1,
                                                                                              ::core::fmt::Display::fmt)],
                                                            })),
            }
        }
    }
    #[allow(dead_code)]
    pub const DUMMY_TYPE_ID: usize = std::usize::MAX;
    #[derivative(Debug, PartialEq, Clone)]
    pub enum TyKind {

        #[derivative(Debug = "transparent")]
        Array(Box<Ty>),

        #[derivative(Debug = "transparent")]
        Tup(Vec<Ty>),
        Num,
        Bool,
        Text,
        Infer,
        Id(usize),

        #[derivative(Debug = "transparent")]
        Poly(Ident),

        #[derivative(Debug = "transparent")]
        Struct(Struct),

        #[derivative(Debug = "transparent")]
        Enum(Enum),

        #[derivative(Debug = "transparent")]
        Path(Path),
    }
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for TyKind {
        fn clone(&self) -> Self {
            match *self {
                TyKind::Array(ref __arg_0) => {
                    TyKind::Array(__arg_0.clone())
                }
                TyKind::Tup(ref __arg_0) => { TyKind::Tup(__arg_0.clone()) }
                TyKind::Num => { TyKind::Num }
                TyKind::Bool => { TyKind::Bool }
                TyKind::Text => { TyKind::Text }
                TyKind::Infer => { TyKind::Infer }
                TyKind::Id(ref __arg_0) => { TyKind::Id(__arg_0.clone()) }
                TyKind::Poly(ref __arg_0) => { TyKind::Poly(__arg_0.clone()) }
                TyKind::Struct(ref __arg_0) => {
                    TyKind::Struct(__arg_0.clone())
                }
                TyKind::Enum(ref __arg_0) => { TyKind::Enum(__arg_0.clone()) }
                TyKind::Path(ref __arg_0) => { TyKind::Path(__arg_0.clone()) }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for TyKind {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                TyKind::Array(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                TyKind::Tup(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                TyKind::Num => {
                    let mut __debug_trait_builder = __f.debug_tuple("Num");
                    __debug_trait_builder.finish()
                }
                TyKind::Bool => {
                    let mut __debug_trait_builder = __f.debug_tuple("Bool");
                    __debug_trait_builder.finish()
                }
                TyKind::Text => {
                    let mut __debug_trait_builder = __f.debug_tuple("Text");
                    __debug_trait_builder.finish()
                }
                TyKind::Infer => {
                    let mut __debug_trait_builder = __f.debug_tuple("Infer");
                    __debug_trait_builder.finish()
                }
                TyKind::Id(ref __arg_0) => {
                    let mut __debug_trait_builder = __f.debug_tuple("Id");
                    let _ = __debug_trait_builder.field(&__arg_0);
                    __debug_trait_builder.finish()
                }
                TyKind::Poly(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                TyKind::Struct(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                TyKind::Enum(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
                TyKind::Path(ref __arg_0) => {
                    ::std::fmt::Debug::fmt(__arg_0, __f)
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for TyKind {
        fn eq(&self, other: &Self) -> bool {
            (::std::mem::discriminant(&*self) ==
                 ::std::mem::discriminant(&*other)) &&
                match (&*self, &*other) {
                    (TyKind::Array(ref __self_0),
                     TyKind::Array(ref __other_0)) => {
                        true && __self_0 == __other_0
                    }
                    (TyKind::Tup(ref __self_0), TyKind::Tup(ref __other_0)) =>
                    {
                        true && __self_0 == __other_0
                    }
                    (TyKind::Num, TyKind::Num) => { true }
                    (TyKind::Bool, TyKind::Bool) => { true }
                    (TyKind::Text, TyKind::Text) => { true }
                    (TyKind::Infer, TyKind::Infer) => { true }
                    (TyKind::Id(ref __self_0), TyKind::Id(ref __other_0)) => {
                        true && __self_0 == __other_0
                    }
                    (TyKind::Poly(ref __self_0), TyKind::Poly(ref __other_0))
                    => {
                        true && __self_0 == __other_0
                    }
                    (TyKind::Struct(ref __self_0),
                     TyKind::Struct(ref __other_0)) => {
                        true && __self_0 == __other_0
                    }
                    (TyKind::Enum(ref __self_0), TyKind::Enum(ref __other_0))
                    => {
                        true && __self_0 == __other_0
                    }
                    (TyKind::Path(ref __self_0), TyKind::Path(ref __other_0))
                    => {
                        true && __self_0 == __other_0
                    }
                    _ => {
                        {
                            ::std::rt::begin_panic("internal error: entered unreachable code")
                        }
                    }
                }
        }
    }
    impl fmt::Display for TyKind {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                       &match (&self.to_str(),)
                                                            {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    impl TryFrom<Ident> for TyKind {
        type Error = ();
        fn try_from(ident: Ident) -> Result<TyKind, Self::Error> {
            match ident.lexeme.as_str() {
                "Zahl" => Ok(TyKind::Num),
                "Bool" => Ok(TyKind::Bool),
                "Text" => Ok(TyKind::Text),
                _ => Err(()),
            }
        }
    }
    impl TyKind {
        pub fn infer_internal_types(&self) -> TyKind {
            match self {
                TyKind::Path(ref p) if p.len() == 1 => {
                    let seg = &p.first().unwrap().lexeme;
                    match seg.as_str() {
                        "Zahl" => TyKind::Num,
                        "Text" => TyKind::Text,
                        "Bool" => TyKind::Bool,
                        _ => self.clone(),
                    }
                }
                TyKind::Array(ref t) =>
                TyKind::Array(Box::new(Ty{kind: t.kind.infer_internal_types(),
                                          span: t.span,})),
                TyKind::Tup(ref elems) => {
                    let mut new_types = Vec::new();
                    for e in elems {
                        new_types.push(Ty{kind: e.kind.infer_internal_types(),
                                          span: e.span,});
                    }
                    TyKind::Tup(new_types)
                }
                _ => self.clone(),
            }
        }
        fn from_lit(l: &Lit) -> Self {
            match l {
                Lit::Number(_) => TyKind::Num,
                Lit::String(_) => TyKind::Text,
                Lit::Bool(_) => TyKind::Bool,
            }
        }
        fn to_str(&self) -> String {
            match self {
                TyKind::Array(elem) => {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["[",
                                                                              "]"],
                                                                            &match (&elem.kind,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                }
                TyKind::Id(id) => {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["$"],
                                                                            &match (&id,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                }
                TyKind::Infer => "Infer".to_string(),
                TyKind::Poly(elem) => {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["$",
                                                                              "$"],
                                                                            &match (&elem.lexeme,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                }
                TyKind::Num => "Zahl".to_string(),
                TyKind::Bool => "Bool".to_string(),
                TyKind::Path(p) => {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&p,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                }
                TyKind::Text => "Text".to_string(),
                TyKind::Tup(elems) => {
                    let mut sb = String::from("(");
                    for e in elems {
                        sb.push_str({
                                        let res =
                                            ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                                                &match (&e.kind,)
                                                                                                     {
                                                                                                     (arg0,)
                                                                                                     =>
                                                                                                     [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                   ::core::fmt::Display::fmt)],
                                                                                                 }));
                                        res
                                    }.as_str());
                    }
                    sb.push(')');
                    sb
                }
                TyKind::Struct(strct) => {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["struct: "],
                                                                            &match (&strct.name.lexeme,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                }
                TyKind::Enum(enm) => {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["enum: "],
                                                                            &match (&enm.name.lexeme,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                }
            }
        }
    }
    pub struct Typer {
        cxt: Cxt<String, TyKind>,
        subst: Vec<TyKind>,
        cons: Vec<Constraint>,
        diagnostics: Vec<Diagnostic>,
    }
    impl Typer {
        pub fn new() -> Self {
            Self{cons: Vec::new(),
                 cxt: Cxt::new(),
                 subst: Vec::new(),
                 diagnostics: Vec::new(),}
        }
        fn new_id(&mut self) -> TyKind {
            let res = TyKind::Id(self.subst.len());
            self.subst.push(res.clone());
            res
        }
        pub fn infer_types(&mut self, ast: &mut AST) {
            for d in ast.iter() {
                if let Decl::TyDecl(t) = d {
                    match t {
                        TyDecl::Struct(s) =>
                        self.cxt.insert_global(s.name.lexeme.clone(),
                                               TyKind::Struct(s.clone())),
                        TyDecl::Enum(e) =>
                        self.cxt.insert_global(e.name.lexeme.clone(),
                                               TyKind::Enum(e.clone())),
                    }
                }
            }
            for d in ast.iter_mut() {
                if let Decl::Fn(f) = d { self.infer_fn(f); }
            }
            match &self.cons {
                tmp => {
                    {
                        ::std::io::_eprint(::core::fmt::Arguments::new_v1_formatted(&["[",
                                                                                      ":",
                                                                                      "] ",
                                                                                      " = ",
                                                                                      "\n"],
                                                                                    &match (&"src/typer.rs",
                                                                                            &223u32,
                                                                                            &"&self.cons",
                                                                                            &&tmp)
                                                                                         {
                                                                                         (arg0,
                                                                                          arg1,
                                                                                          arg2,
                                                                                          arg3)
                                                                                         =>
                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::core::fmt::Display::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                       ::core::fmt::Display::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                       ::core::fmt::Display::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                       ::core::fmt::Debug::fmt)],
                                                                                     },
                                                                                    &[::core::fmt::rt::v1::Argument{position:
                                                                                                                        0usize,
                                                                                                                    format:
                                                                                                                        ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                            ' ',
                                                                                                                                                        align:
                                                                                                                                                            ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                        flags:
                                                                                                                                                            0u32,
                                                                                                                                                        precision:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                        width:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,},},
                                                                                      ::core::fmt::rt::v1::Argument{position:
                                                                                                                        1usize,
                                                                                                                    format:
                                                                                                                        ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                            ' ',
                                                                                                                                                        align:
                                                                                                                                                            ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                        flags:
                                                                                                                                                            0u32,
                                                                                                                                                        precision:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                        width:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,},},
                                                                                      ::core::fmt::rt::v1::Argument{position:
                                                                                                                        2usize,
                                                                                                                    format:
                                                                                                                        ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                            ' ',
                                                                                                                                                        align:
                                                                                                                                                            ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                        flags:
                                                                                                                                                            0u32,
                                                                                                                                                        precision:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                        width:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,},},
                                                                                      ::core::fmt::rt::v1::Argument{position:
                                                                                                                        3usize,
                                                                                                                    format:
                                                                                                                        ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                            ' ',
                                                                                                                                                        align:
                                                                                                                                                            ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                        flags:
                                                                                                                                                            4u32,
                                                                                                                                                        precision:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                        width:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,},}]));
                    };
                    tmp
                }
            };
            match &self.diagnostics {
                tmp => {
                    {
                        ::std::io::_eprint(::core::fmt::Arguments::new_v1_formatted(&["[",
                                                                                      ":",
                                                                                      "] ",
                                                                                      " = ",
                                                                                      "\n"],
                                                                                    &match (&"src/typer.rs",
                                                                                            &224u32,
                                                                                            &"&self.diagnostics",
                                                                                            &&tmp)
                                                                                         {
                                                                                         (arg0,
                                                                                          arg1,
                                                                                          arg2,
                                                                                          arg3)
                                                                                         =>
                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::core::fmt::Display::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                       ::core::fmt::Display::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                       ::core::fmt::Display::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                       ::core::fmt::Debug::fmt)],
                                                                                     },
                                                                                    &[::core::fmt::rt::v1::Argument{position:
                                                                                                                        0usize,
                                                                                                                    format:
                                                                                                                        ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                            ' ',
                                                                                                                                                        align:
                                                                                                                                                            ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                        flags:
                                                                                                                                                            0u32,
                                                                                                                                                        precision:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                        width:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,},},
                                                                                      ::core::fmt::rt::v1::Argument{position:
                                                                                                                        1usize,
                                                                                                                    format:
                                                                                                                        ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                            ' ',
                                                                                                                                                        align:
                                                                                                                                                            ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                        flags:
                                                                                                                                                            0u32,
                                                                                                                                                        precision:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                        width:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,},},
                                                                                      ::core::fmt::rt::v1::Argument{position:
                                                                                                                        2usize,
                                                                                                                    format:
                                                                                                                        ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                            ' ',
                                                                                                                                                        align:
                                                                                                                                                            ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                        flags:
                                                                                                                                                            0u32,
                                                                                                                                                        precision:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                        width:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,},},
                                                                                      ::core::fmt::rt::v1::Argument{position:
                                                                                                                        3usize,
                                                                                                                    format:
                                                                                                                        ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                            ' ',
                                                                                                                                                        align:
                                                                                                                                                            ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                        flags:
                                                                                                                                                            4u32,
                                                                                                                                                        precision:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,
                                                                                                                                                        width:
                                                                                                                                                            ::core::fmt::rt::v1::Count::Implied,},}]));
                    };
                    tmp
                }
            };
        }
        fn infer_fn(&mut self, f: &mut FnDecl) -> Result<(), Diagnostic> {
            self.cxt.make_clean();
            for p in f.header.params.iter() {
                match p.ty.kind {
                    TyKind::Poly(_) => {
                        ::std::rt::begin_panic("not yet implemented")
                    }
                    _ =>
                    self.cxt.insert(p.name.lexeme.clone(), p.ty.kind.clone()),
                }
            }
            self.infer_block(&mut f.body)
        }
        fn infer_block(&mut self, block: &mut Block)
         -> Result<(), Diagnostic> {
            self.cxt.make();
            for stmt in block.stmts.iter_mut() { stmt.accept(self)?; }
            self.cxt.drop();
            Ok(())
        }
        pub fn span_err(&mut self, kind: ErrKind, span: Span) -> Diagnostic {
            let diag = Diagnostic{kind, suggestions: Vec::new(), span,};
            self.diagnostics.push(diag.clone());
            diag
        }
        fn check_enum_arm(&mut self, enum_arm: Path)
         -> Result<Ty, Diagnostic> {
            let name = enum_arm.first().unwrap();
            { ::std::rt::begin_panic("not yet implemented") }
        }
        pub fn infer(&mut self, e: &Expr) -> Result<TyKind, Diagnostic> {
            match e.node {
                ExprKind::Binary { ref lhs, op: _, ref rhs } => {
                    let lhs = self.infer(lhs)?;
                    let rhs = self.infer(rhs)?;
                    self.cons.push(Constraint::Eq(lhs, TyKind::Num));
                    self.cons.push(Constraint::Eq(rhs, TyKind::Num));
                    Ok(TyKind::Num)
                }
                ExprKind::Logical { ref lhs, op: _, ref rhs } => {
                    let lhs = self.infer(lhs)?;
                    let rhs = self.infer(rhs)?;
                    self.cons.push(Constraint::Eq(lhs, TyKind::Bool));
                    self.cons.push(Constraint::Eq(rhs, TyKind::Bool));
                    Ok(TyKind::Bool)
                }
                ExprKind::Unary { ref rhs, ref op } => {
                    let rhs = self.infer(rhs)?;
                    let tk =
                        match op {
                            UnaryOp::Minus => TyKind::Num,
                            UnaryOp::Not => TyKind::Bool,
                        };
                    self.cons.push(Constraint::Eq(rhs, tk.clone()));
                    Ok(tk)
                }
                ExprKind::Array(ref arr) => {
                    let first_tk =
                        match arr.first() {
                            Some(e) => self.infer(e)?,
                            None => self.new_id(),
                        };
                    let elem_ty =
                        TyKind::Array(box
                                          Ty{kind: first_tk.clone(),
                                             span: e.span,});
                    for elem in arr {
                        let tk = self.infer(elem)?;
                        self.cons.push(Constraint::Eq(tk, first_tk.clone()));
                    }
                    Ok(elem_ty)
                }
                ExprKind::Tup(ref tup) => {
                    let mut t = Vec::new();
                    for elem in tup {
                        t.push(Ty{span: elem.span, kind: self.infer(elem)?,});
                    }
                    Ok(TyKind::Tup(t))
                }
                ExprKind::Path(ref path) => {
                    let name = path.first().unwrap().lexeme.clone();
                    match path.len() {
                        1 =>
                        match self.cxt.get(&name) {
                            Some(tk) => Ok(tk.clone()),
                            None =>
                            Err(self.span_err(ErrKind::Type(TypeErr::VarNotFound(name.clone())),
                                              path.span)),
                        },
                        _ => {
                            let name = path.first().unwrap();
                            { ::std::rt::begin_panic("not yet implemented") };
                        }
                    }
                }
                ExprKind::Struct { ref name, ref members } =>
                self.infer_struct_lit(name, members),
                ExprKind::Range(ref from, ref to) => {
                    let ty =
                        Ty{kind: TyKind::Num,
                           span: from.span.combine(&to.span),};
                    Ok(TyKind::Array(Box::new(ty)))
                }
                ExprKind::Lit(ref lit) => Ok(Self::infer_lit(lit)),
                ExprKind::Index { ref callee, ref index } => {
                    let index = self.infer(index)?;
                    let callee_ty = self.infer(callee)?;
                    self.cons.push(Constraint::Eq(index, TyKind::Num));
                    Ok(TyKind::Num)
                }
                ExprKind::This {  } => {
                    ::std::rt::begin_panic("not yet implemented")
                }
                ExprKind::Call { ref callee, ref args } => {
                    ::std::rt::begin_panic("not yet implemented")
                }
                ExprKind::Intrinsic { ref kind, ref args } => {
                    ::std::rt::begin_panic("not yet implemented")
                }
                ExprKind::Field(ref callee, ref field) => {
                    ::std::rt::begin_panic("not yet implemented")
                }
                ExprKind::Val(ref val) => {
                    ::std::rt::begin_panic("not yet implemented")
                }
            }
        }
        fn infer_lit(lit: &Lit) -> TyKind {
            match lit {
                Lit::Number(_) => TyKind::Num,
                Lit::String(_) => TyKind::Text,
                Lit::Bool(_) => TyKind::Bool,
            }
        }
        fn infer_struct_lit(&mut self, name: &Ident, members: &Vec<Member>)
         -> Result<TyKind, Diagnostic> {
            let str_name = name.lexeme.clone();
            match self.cxt.get(&str_name) {
                Some(TyKind::Struct(s)) => {
                    Self::check_duplicates_field(&members)?;
                    self.check_forgotten_fields(&s, &members);
                    let member_table =
                        s.fields.iter().map(|field|
                                                (&field.name.lexeme,
                                                 field.ty.kind.clone())).collect::<HashMap<_,
                                                                                           _>>();
                    for member in members {
                        let member_ty = self.infer(&member.init)?;
                        match member_table.get(&member.name.lexeme) {
                            Some(ty) =>
                            self.cons.push(Constraint::Eq(ty.clone(),
                                                          member_ty.clone())),
                            None => continue ,
                        }
                    }
                    Ok(TyKind::Struct(s.clone()))
                }
                _ => {
                    let err = ErrKind::Type(TypeErr::TyNotFound(str_name));
                    Err(self.span_err(err, name.span))
                }
            }
        }
        fn check_duplicates_field(members: &Vec<Member>)
         -> Result<(), Diagnostic> {
            let mut fields = HashSet::new();
            for member in members {
                if !fields.insert(&member.name.lexeme) {
                    return Err(Diagnostic{kind:
                                              ErrKind::Type(TypeErr::DuplicateLitField(member.name.lexeme.clone())),
                                          span: member.span,
                                          suggestions:
                                              <[_]>::into_vec(box
                                                                  ["Versuche das doppelte Feld in dem Strukturliteral zu entfernen!".to_string()]),});
                }
            }
            Ok(())
        }
        fn check_forgotten_fields(&mut self, s: &Struct,
                                  members: &Vec<Member>) {
            let mut member_table =
                s.fields.iter().map(|field|
                                        (&field.name.lexeme,
                                         field.span)).collect::<HashMap<_,
                                                                        _>>();
            for member in members {
                let field = &member.name.lexeme;
                match member_table.remove(field) {
                    None => {
                        self.span_err(ErrKind::Type(TypeErr::InvalidField(s.name.lexeme.clone(),
                                                                          field.clone())),
                                      member.span);
                    }
                    Some(_) => continue ,
                }
            }
            for (name, span) in member_table {
                let err = ErrKind::Type(TypeErr::MissingField(name.clone()));
                self.span_err(err, span);
            }
        }
    }
    impl Visitor for Typer {
        type Result = Result<(), Diagnostic>;
        fn visit_decl(&mut self, decl: &mut Decl) -> Self::Result {
            match decl { Decl::Fn(f) => self.infer_fn(f)?, _ => { } };
            Ok(())
        }
        fn visit_stmt(&mut self, stmt: &mut Stmt) -> Self::Result {
            match stmt {
                Stmt::VarDef(ref mut vd) => {
                    let tk =
                        match vd.ty.kind {
                            TyKind::Infer => self.new_id(),
                            _ => vd.ty.kind.clone(),
                        };
                    vd.ty.kind = tk.clone();
                    self.cxt.insert(vd.pat.lexeme.clone(), tk.clone());
                    let init_ty = self.infer(&vd.init).unwrap();
                    self.cons.push(Constraint::Eq(init_ty, tk.clone()))
                }
                Stmt::Assign { ref lhs, ref rhs, span: _ } => {
                    let lhs = self.infer(lhs).unwrap();
                    let rhs = self.infer(rhs).unwrap();
                    self.cons.push(Constraint::Eq(lhs, rhs))
                }
                Stmt::Block(ref mut block) => self.infer_block(block)?,
                Stmt::Expr(ref e) => { self.infer(e)?; }
                Stmt::For { ref vardef, ref body, span: _ } => {
                    self.cxt.make();
                    let loop_var = vardef.pat.lexeme.clone();
                    let init_tk = self.infer(&vardef.init)?;
                    self.cxt.insert(vardef.pat.lexeme.clone(), init_tk);
                    self.cxt.drop();
                }
                Stmt::While { ref cond, ref mut body, span: _ } => {
                    let cond_ty = self.infer(cond)?;
                    self.cons.push(Constraint::Eq(TyKind::Bool, cond_ty));
                    self.infer_block(body)?;
                }
                Stmt::If {
                ref cond,
                ref mut body,
                ref mut else_branches,
                ref mut final_branch,
                span: _ } => {
                    let cond = self.infer(cond)?;
                    self.cons.push(Constraint::Eq(cond, TyKind::Bool));
                    self.infer_block(body)?;
                    for branch in else_branches.iter_mut() {
                        let cond = self.infer(&branch.cond)?;
                        self.cons.push(Constraint::Eq(cond, TyKind::Bool));
                        self.infer_block(&mut branch.body)?;
                    }
                    if let Some(fb) = final_branch {
                        self.infer_block(&mut fb.body)?;
                    }
                }
                Stmt::Ret(..) | Stmt::Break(..) | Stmt::Continue(..) => { }
            };
            Ok(())
        }
        fn visit_expr(&mut self, expr: &mut Expr) -> Self::Result {
            self.infer(&expr)?;
            Ok(())
        }
    }
}
#[macro_use]
extern crate failure;
use self::session::*;
const STEGI_ASCII: &str =
    r#"
 _________________________________________
/ Fehler im Code zu suchen ist doppelt so \
| schwer, wie ihn zu schreiben. Wenn sie  |
| Code so raffiniert wie moeglich         |
| schreiben, sind Sie also per defintion  |
| nicht intelligent genug, um ihn zu      |
\ debuggen. - Brian W. Kernighan          /
 -----------------------------------------
\                             .       .
 \                           / `.   .' "
  \                  .---.  <    > <    >  .---.
   \                 |    \  \ - ~ ~ - /  /    |
         _____          ..-~             ~-..-~
        |     |   \~~~\.'                    `./~~~/
       ---------   \__/                        \__/
      .'  O    \     /               /       \  "
     (_____,    `._.'               |         }  \/~~~/
      `----.          /       }     |        /    \__/
            `-.      |       /      |       /      `. ,~~|
                ~-.__|      /_ - ~ ^|      /- _      `..-'
                     |     /        |     /     ~-.     `-. _  _  _
                     |_____|        |_____|         ~ - . _ _ _ _
"#;
fn main() {
    {
        ::std::io::_print(::core::fmt::Arguments::new_v1(&["################################ Stegi ################################ \n"],
                                                         &match () {
                                                              () => [],
                                                          }));
    };
    let path = PathBuf::from("examples/test.st");
    let mut d = Driver::new(<[_]>::into_vec(box [path]));
    d.compile();
}
